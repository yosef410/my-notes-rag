
# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GWY4tayt08UyFxEChZZWDo7TPolfxb_R
"""

#day 1
neam = "golem" #str
age = 150 #int
#floot = 10.2
#boolan = true\false
print("hi along time ago in europ was someone calld ", neam, " and he was ", age, " yes i know pretty old lol")
# hello wolrd nerd

#day 2
def off_agin(a, b):
    return a * b

print(off_agin(4, 6))
# beasic return in fun

#day 3
t = 3
for u in range (t):
    print (t)
for tom in range (7, 10):
    print (tom,"dumb")
x = 5
while x <= 7:
      print (x)
      x += 1
#for , range and while

#day 4
def funny_q(e, b):
    for v in range(2):
        print(e, b)# wiche meen whatever i put in the parmater its gonna be 2 times
funny_q("dog","cat")
#for in range, inside the fun

#day 5
def jew(a, e):
    return a + e # the return make the neam jew to active the +
mom = jew( 9, 3)
print(mom)

def arab(x):
    print('i always love', x , 'forever')
arab("jews")

def frog(a, b):
    return a * b
print(frog(4, 4))
#return with list , and just with fun and ,print inside the fun

#day 6
you = [1, 5, 10]
for x in you:
    print(x)

def dog_cat(v):
    for item in v:
        print("hI", item )
lion = ["yoel", "abi", "shalom"]
print(dog_cat(lion))#why here not doing print becuas you alredy put print in the fun

def con(t):
    for f in range(t):
        print(f)
con (5)
# list and for , fun with for with list , and for in range in fun

#day 7
def wow_i(can):
    new = []
    for j in can:
        new.append(j * 2)
    return new
print(wow_i([2, 5, 8]))

def you(non):
    for y in non:
        print(y * 4)
you([2, 5, 6,])
# list inside the fun with loop ,same thing but whit print inside , .upeer()

print('yoel', "shlomi".upper())

#day 8
def martinez(haha):
    old = []#new list
    for x in haha:
        if x % 4 == 0:
             old.append(x)#the append desaids what kind of  list
    return old
print(martinez([1, 4, 8, 7, 10]))

def grok(elon):
    need = []
    dont = []#list num 2
    for p in elon:
        if p % 2 == 0:
           need.append(p)
        else:
           dont.append(p)
    return need, dont
print(grok([3, 4, 8, 9, 5]))

def boker(hi):
    filter =[]
    for w in hi:
        if w > 10:
           filter.append(w * 2)
    return filter
print(boker([5, 12, 7, 30, 2, 99]))
# fun with loop list for, if madolo % , two list with else , return of corse

#day 9

def wake_up(h):
    if h > 10:
        return "big"
    elif h == 10:
          return "crul"
    else:
         return "small"

print(wake_up(13))
print(wake_up(10))
print(wake_up(7))

def good(a, b):
    if a > 5 or b > 20 :
        return "match"
    else:
        return "false"

print(good(6, 5))
print(good(2, 30))
print(good(2, 5))

def last(u):
    if u % 2 == 0:
        return "even"
    else:
        return "add"
print(last(8))
print (last(3))
print(last(30))
# if elif else , if or fun (true false) , add even if else %%%%%%

#day 10
def  hello(x):
     return x * 3
def mine_too(a, b):
    list_v = a + b
    return hello(list_v)
print(mine_too(3, 5))
# fun inside fun * with +

#day 11
x = 10
def you(f):
    z = x + f
    return z
moto = you(5)
print(moto * 2)# the reasen we make a list inside the fun for the * in ptint and more usege

def yoy(a, b):
    return a * b
print(yoy(6, 7))
# useing vala outside the fun with inside

#day 12
def ror(r):
    what = []
    for x in r:
      what.append(x * 2)
    return what
print(ror([5, 8, 10]))

def bob(x):
    moll = []
    for v in x:
        moll.append(v.upper())
    return moll
print(bob(["me", "you"]))


def helo(y):
    list = []
    for x in y:
        if x % 2 == 0:
          list.append(str(x))
    return list
print(helo([4, 6, 10, 3, 7, 9]))
# diffrent append and the most importent not useing return for all the loop

#day 13
def monday(xox):
    klik = []
    for x in xox:
        if x > 10:
            klik.append(x)
    return klik # Changed to return the list 'klik'
print(monday([5, 2, 18, 50]))

def thersday(yoy):
    loli = 0
    for x in yoy:
        if x % 2 == 0:
            loli += 1
    return loli
print(thersday([1, 4, 8, 12, 30, 9]))

def wensday(mol):
    wow = []
    for v in mol:
        if v > 10:
           wow.append(v * 10)
        else:
           wow.append(v)
    return wow
print(wensday([11, 5, 45, 3, 100]))
# we learn again about if > 10,(n* 10) in append, valabele of 0 thet can brack 2 and we put += 1

# day 14
def foro(u):
    list = []
    for p in u:
        if p % 2 == 1:
         list.append(p)
    return list
print (foro([4, 6, 8, 9, 1, 3, 7]))

def conj(num):
    korp = 0
    for y in num:
        if y > 50:
           korp += 1 # Corrected: Increment korp when y is greater than 50
    return korp
print(conj([51, 4, 7, 55, 99, 100]))
# the odd and even in % 2==1 and uesing the +=1 to tast the code not to cacilet

#day 15
for o in range (3):
    for w in range (2):
        print("o=" ,o ,"w=", w)

def jews(yoy):
    pop = []
    for n in yoy:
        if n > 6 and n % 2==0:
           pop.append(n)
    return pop
print(jews([7, 8, 9, 12, 3]))


def arab(list1, list2):
    saudi = []
    for x in list1:
        for v in list2:
            if x * v > 10:
              saudi.append(x * v)
    return saudi
print (arab([3, 6, 8],[9, 1, 2]))
# we learn 1 the in and out with 2 parameters, 2 for loops, if condition and list manipulation.(for all the out the in print)

#day 16
for c in [1, 8, 9, 4, 5, 6]:
    if c == 5:
       break
    print(c)
print("#")
for v in [5, 10, 20, 25]:
    if v == 10:
         continue
    print(v)
def find_until(o):
    poor = []
    for v in o:
        if v == 100:
           break
        poor.append(v) # Move append here to collect elements before 100
    return poor # Move return outside the loop
print(find_until([3, 5, 44, 100, 77]))
# we learn break and continue in a loop and in fun

#day 17
def gorg(o):
    for n in o:
        if n % 2 == 0:
           return n
print(gorg([1,11, 9, 2, 5, 4, 8, 1]))
print('#')
for u in [3, 7, 10, 5, 11]:
    if u > 8:
       continue
    print(u)
print("#")
for t in [2, 3, 6, 7, 9, 8]:
    if t < 4:
       continue
    print(t)
# continue and break toghter in > < ==

# day 18

def hello(pop):
    loop = []
    for q in pop:
        if q > 50:
          break
        elif q % 2==0:
           loop.append(q)
    return loop
print(hello([5, 3, 6, 8, 55, 90]))

def nshma(aw1, bw2):
    list = []
    for x in aw1:
        for y in bw2:
            if x * y > 10:
                list.append(x * y)
    return list
print(nshma([1, 2, 3],[4, 5]))

def yoyo(o):
    mol = []
    for x in o:
        if x < 5:
            continue
        mol.append(x)
    return mol
print(yoyo([1, 3, 6, 8, 2]))

def googo(p):
    dora = []
    for m in p:
        if m > 20:
           break
        if m % 2 != 0:
           dora.append(m)
    return dora
print(googo([3, 7, 6, 12, 25, 8]))
# we learn break and continue with % with 2 parm a, b

# day 19
def gog(o):
    i = 0
    list = []
    while i < len(o):
         if o[i]% 2 == 0:
           list.append(o[i])
         if o[i] > 20:
              break
         i += 1
    return list
print(gog([4, 7, 8, 22, 2]))

nums = [3, 8, 15, 22]
i = 0
while i < len(nums):
     print(nums[i])
     i += 1
# we learn while and break in fun

# day 20
pod = "david"
mom = "rvka"
print(pod[0])
print('#')
for char in "hello":
    print(char.upper())
def morning(hi):
    count = 0
    for y in hi:
        if y == "a":
            count += 1
    return count
print(morning("am i realy here hahah"))

if "g" in "green":
    print("right")

def hi(u):
    list = ""   # str
    for x in u:
        if x == "v": # == or !=
           list += x
    return list
print(hi("volvo var"))

print(len("moran"))

e = 0
word = "hello"
while e < len(word):
      print(word[e])
      e += 1
# we learn string in fun with while and len , and += 1 , if g in green , list for string, string day ######

# day 21
age = 22
color = "blue"
hungry = False
if age > 20 and age < 50 and not hungry:
    print("he is a old head")
if color == "red" or color == "blue":
         print("hlowd")
if  hungry:
          print("ok babe")

def check_number(y):
    for c in y:
       if c > 10:
         print("good")
       elif c == 7:
         print("ok")
       else:
        print("bad")
check_number([12,9, 7])
# again if elif else condishens

# day 22
its_rain = False
if not its_rain:
  print("zzz")
age = 50
job = True
life= False
if age > 20 and not life and job:
    print("check")
def saterday(a, b):
      if a > 20 :
         if b :
          print("a, b")
         else:
            print("a but not b")
      else:
        print("not a")
saterday(33,False) #####
# true, false ,not, if, and

#day 23
def idk(gog):
    list = []
    for x in gog:
      if x % 2==0 and x > 10:
         list.append(x)
      elif x % 2!= 0 and x < 5:
         list.append(x)
      else:
         list.append(x)
    return list
print(idk([2, 3, 12, 15, 1]))
def funny(a, b):
    lol =[]
    for x in a:
        for y in b:
          if x * y % 2 == 0:
            lol.append(x * y)
    return lol
print(funny([1, 2, 3],[4, 5, 6]))
def action(nums, limit):
    results = []
    i = 0
    while i < len(nums):
      if nums[i]> limit:
          break
      results.append(nums[i])
      i += 1
    return results
print(action([3, 6, 9, 12, 15],10))
# we learn f"{}, diffrent if elif and in a fun

# 24
city = "london"
population = 2000103
print(f"the city of {city} has {population} people")
tor = [5, 6, 7]
for t in tor:
    print(f"{t} squared is {t ** 2}")

num = [10, 15, 20, 25]
for g in num:
    if g % 2 == 0:
        print(f"{g} is even")
    else:
        print(f"{g} is odd")

def introduce(name, hobby):
    return f"hi my name is {name} and i like {hobby}"
list47 = introduce("yoel", "football")
print(list47)

mok = [2, 3]
nun = [5, 6]
for e in mok:
    for w in nun:
        print(f"{e} * {w} = {e * w}")
# diffrent fun in dictonery

# 25
def gog(i):
    if i < 18:
        return "to young"
    if i > 60:
        return "to old"
    else:
        return "yes"
print(gog(20))
def check(a, b):
    if a > 10 and b < 5:
       return "case 1"
    if a > 10 and not b < 5:
       return "case 2 "
    return "case 3"
print(check(11, 7))
def big(num):
    for t in num:
        if t > 30:
           return "one"
        elif t == 4:
           return "match"
    return "two"
print(big([3]))

for c in [1, 3 ,5, 8]:
      if c == 5:
        break# or continue
      print(c) # if print outside so the braek not uesful why becous is not in if but in for then if is only %==
print("#")
def rood(t):
     for p in t:
         if p == 10:
            return "stop"
         print(p)
     return "done"
print(rood([3, 5, 9, 11,10, 70, 2]))
# if and elif not true false diffrent return break or continue

# day 26
def stop(p):
    ouou = []
    for t in p:
      if t < 0:
        break
      ouou.append(t)
    return ouou
print(stop([4, 6, 8, 1, -1, 10]))
def move(e):
    for q in e:
      if q < 0:
        break
      print(q)
move([5, 2, 8, -1, 10]) #######

def numer(tree):
    return [ v * 3 for v in tree]
print(numer([4, 6, 2]))
def count(i):
    frog = 0
    for w in i:
      if w % 2== 0:
         frog += 1
    return frog
print(count([5, 4, 7, 8, 10, 5, 9]))
# we learn why we need list in def and why we dont becose if not its only for one thing only , quiq wey to do list inside return , and count %2==0

# day 27
def is_big(o):
    if o > 50 and o < 90:
      return True# without usieng else:
    return False
print(is_big(80))
print(is_big(10))
print("#")
def g(y):
    if y == 4 or y == 6 or y == 5:
      return True
    return False
print(g(7))
print(g(4))
def h(r):
    if not r == 4:
      return "green"
    return "yellw"
print(h(4))
print(h(7))
print("#")
def not_even(nn):
    for v in nn:
      if v % 2==0:
         return True
    return "wow"
print(not_even([3, 7, 9]))
print(not_even([3, 6, 9]))
# we not always need else we can just do return , or , if

# day 28
def collect(nums):
    list5 = []
    for n in nums:
        if n > 20:
           break
        elif n % 2 == 0:
          continue
        list5.append(n)
    return list5
print(collect([5, 8, 12, 3, 18, 21]))
def check(y):
       if y > 50:
          return "big"
       elif y > 20:
          return "meddium"
       else:
          return "small"
print(check(60))
print(check(35))
print(check(10))
def martin(u, h):
    list6= []
    for i in u:
      for o in h:
          if i * o > 10:
               list6.append(i * o)
    return list6
print(martin([2, 3], [1,5]))
# idk haha more on return if elif and else list break and continue

# day 29
def mor(i):
    return i* 2
print(mor(6))
num = [1, 2, 3]
num.append(4)
print(num)

rool = 20
if rool >= 18:
       print("adult")
else:
   print("not adult")
for y in range(2, 5):
    print(y)
def monday(text):
    word = text.split()
    count = {}
    for w in word:
       if w in count:
          count[w] += 1
       else:
          count[w] = 1
    return count
print(monday("hello hello world"))

def bot(messege):
    msg = messege.lower().strip()
    if msg == "hi":
       return "Hello"
    elif msg == "bye":
        return "Goodbye"
    elif msg == "how are you":
        return "Im good how are you"
    else:
       return "I dont understand"
print(bot("hi     "))
print(bot("HOW ARE YOU    "))
print(bot("what    "))
# lower and split and {} what its mean as a list , and append

#day 30
def first(i):
    return i + 1
def sacend(u):
    dobel = u * 2
    return first(dobel)
print(sacend(7))

def zool(y):
    if y % 2== 0:
       kind = "even"
    else:
        kind = "odd"
    rome = y * 2
    return kind, rome
print(zool(4))

def zoo(t):
    t=t.lower()
    t=t.replace("!", "")
    t=t.strip()
    return t
print(zoo("  HELLO!!!!!!  "))
def proper_message(msg):
    cleaner = zoo(msg)
    words = cleaner.split()
    return words
print(proper_message(" HI HOW ARE YOU !!!!     "))####

# day 31
def count(pop):
   wow = 0
   for n in pop:
       if n % 2 == 0:
          wow += 1
       return n
print(count([3, 6, 8, 2, 1, 5, 7]))
def first(o):
    for x in o:
       if len(x) > 4:
          return x
    return "none"
print(first(["hi" , "blue", "you", "football","mine"]))

def ilmter(wow):
    more = []
    for f in wow:
      if f > 10 and f % 2 == 0:
        more.append(f)
    return more
print(ilmter([5, 12, 17, 20, 4, 30]))

def name_check(text):
    clean = text.strip().lower()
    if clean == "joseph":
        return "Thats your name!"
    elif clean == "yoel":
        return "Nice name!"
    else:
        return "I dont know this name"
print(name_check("  joseph   "))
print(name_check("YOEL    "))
print(name_check("mike  "))
# mini robot lower and strip len > bigger then 4, count += how many times the correct answer

# day 32
def tierd(p):
    word = p.strip().lower()
    if word == "pyton":
        return "yes"
    return "no"
print(tierd("   PYTON "))
def count_odd_even(nums):
    odd = 0
    even = 0
    for b in nums:
        if b % 2 == 0:
           even  += 1
        else:
           odd   += 1
    return even, odd
print(count_odd_even([1, 2, 3, 4, 5, 6, 7]))
def mine_too(nu):
    lisr = min(nu)
    lise = max(nu)
    return lisr, lise
print(mine_too([-7, 4, 8, 20, 66,9]))
# agaim lower . split same line , lists inside if , min , max

# day 33
def count(p):
    cool = 0
    for x in p:
       if x > 10:
        cool += 1
    return cool
print(count([4, 77, 8, 10, 44]))
def t(i):
    loop = []
    for w in i:
       if len(w) >= 4:# or just >
          loop.append(w)
    return loop
print(t(["hi","help","continue", "brake" ]))
def new(aba):
    zero = 0
    for f in aba:
       if f % 2 == 0:
          zero += f # f and not +1 the code here is about if % then do + thats why
    return zero
print(new([2, 5, 7, 8, 4, 9 ,10]))

def clean_text(u):
    return u.strip().lower()
def count_words(j):
    clean = clean_text(j)
    words = clean.split()
    return len(words)
print(count_words("    hello my FRIEND how are you   "))
def q(x):
    results = []
    for w in x:
       if w > 50:
         break
       results.append(w)
    return results
print(q([3, 51, 6]))
# len if is biger its will put it , count how many above > 10 , def inside def, and anther exmpel of break

# day 34
pairs = []
for x in [1, 2, 3]:
   for i in ["a", "b"]:
       pairs.append((x, i))
print(pairs)

count = 0
for num in [10, 15, 21, 19, 44]:
   for d in str(num):# the str for indevidual num 1
      if d == "1":
         count += 1
print(count)

mine = []
for word in ["hi", "hello", "amazing"]:
   for e in word:
     if e not in "aeiou":# in or not
      mine.append(e)
print(mine)

pattren = []
for y in range(1, 4):
    row = []
    for j in range (y):
        row.append("*")
    pattren.append(row)
print(pattren)###
# inner for diffrent typs a 1 ,the str is turn num into word and see who is one and how many, on mine we see if we heve the spasific word , first the out side list 1, 4 then conecct it with the inner

# day 35
def thersday(m, l):
    list4 = 0
    for x in m:
      for v in l:
         if (x + v) % 3 == 0:
            list4 += 1
    return list4
print(thersday([3, 5, 7], [1, 2, 3]))
def big(u):
    for n in u:
       if n > 20:
         return n
    return "none"
print(big([4, 7, 9, 25, 10]))
def mix_even(mix, even):
    clock = []
    for f in mix:
       for w in even:
        if (f * w) % 2 == 0:
           clock.append(f * w)
    return clock
print(mix_even([2,4], [1, 3, 5]))
def mistake(text):
    words = text.lower().strip().split()
    coin = 0
    for c in words:
      if len(c)> 3:
        coin += 1
    return coin
print(mistake(" HEllo    this IS your   friend  "))
print("#")
def skip_5(a ,b):
    result = []
    for e in a :
       for c in b:
        if c  % 5 == 0:
           continue
        result.append(e + c)
    return result
print(skip_5([1, 2], [3, 5, 7]))# we see in each num if % 5 3, 7 ar not and then we can do +
def stats(y, c):
    more = y + c # only odd
    less = max(y, c) # only check what bigger
    return more, less
print(stats(5, 12))

hello = {"name": "yoel", "age" : 30, "city" :"nyc" }
hello["age"] += 5
hello["ai"] = "pyton"
print(hello)
# 2 parametrer with continue and% , and agian we learn more on lower act , and len(w), and {}

# day 36
def geet(n):
    list5 = n * 2
    list4 = n % 2 == 0
    return list5, list4
zool = geet(7)
print(f'this is so fucking easy {zool}')

pop = [1, 2, 3, 4, 5]
mom = [v * v for v in pop]
print(mom)
pairs = []
for f in [1, 2, 3]:
   for y in [4, 5]:
     if (f + y) % 2== 0:
      pairs.append(f + y)
print(pairs)
ages = {"bob": 20, "sam": 40}
print(ages["sam"])
def is_like(tool):
    gof = tool.lower().strip()
    you = gof.split()
    longer = [ w for w in you if len(w) > 3]
    return len(longer), longer
print(is_like(" I LOVe   pyThON and code evey day"))

#day 37
def names(num):
    count = 0
    for n in num:
        n_clean = n.strip().lower()
        if n_clean[0] in "eaiou":
          count += 1
    return count
print(names(["Abi", "Ben", "oren", "tom", "ali"]))# the firs word a o a
def know(t):
    kool = []
    for v in t:
      if v > 10:
           kool.append(v * 2)
    return kool
print(know([3, 14, 7, 20]))
def dood(o):
    for w in o:
       if len(w)> 5:
          return w
print(dood(["hi", "python", "ok", "friend"]))
def under_20(m, n):
    real = []
    for x in m :
       for q in n:
         if x + q < 20:
            real.append((x + q))
    return real
print(under_20([5 , 12, 8], [10, 7, 15]))
def yooo(what):
   s = what.strip().lower()
   mor = s.split()
   return len(mor), mor
print(yooo("  BRO    i donT  KnoW"))
# we repat the casic and did retuen in len()  big and small whit a list and with out becose you whant more thn one rsults

# day 38
def number(z):
    if z % 2 == 0:
      return "even", z * 2
    else:
      return "odd", z * 3
more = number(7)
less = number(4)
print(more)
print(less)
def same(s):
    tptp= []
    for a in s:
      if len(a)> 4:
        tptp.append(a)
    return tptp
print(same(["more", "banana", "no", "continue"]))

num = [1, 2, 3, 4]
num.append(8)
lol = [ n for n in num if n % 2 == 0 ]
print(lol)

name = ["jpseph", "abi","abigail"]
nooo = {name: len(name) for name in name}# name yoel :: len(name):: 5
print(nooo)

dobule = lambda x: x* 2
print(dobule(8))

items = [(4, "appel"), (2, "banana"), (3, "kiwi")]
japan = (sorted(items, key=lambda item: item[0]))
print(japan)
# key , sorted, lambda #### 2 idea in return ,{} and loop in list, and we need key and value thats why {}

# day 39
words = ["water", "python", "love", "family"]
lengths = [len(n) for n in words]
print(lengths)

# 2
nums = [3, 5, 7]
mold = {n: n*n for n in nums}
print(mold)

# 3
last_letter = lambda x: x[-1]
print(last_letter("python"))

# 4
names = ["Alice", "Bob", "Charlie", "David"]
world = [n for n in names if n.endswith("e")]
print(world)

off_age = [("Alice",35),("Bob", 30), ("Charlie", 40)]
on_age = (sorted(off_age, key=lambda x: x[1]))
print(on_age)
# key=lambda sorted for num in len words with upeer(), andswith()

# day 40
new = [2, 4, 6]
def wow(t):
    return t * 2
results = list(map(wow,new))
print(f"hahah im so good{results}")

# filter
#dod = [1,2,3,4]
#vov = list(filter(key=lambda x : x % 2 == 0))
#print(vov)
# output 2, 4
words = ["mine", "hi", "watermelon", "code","z"]
reasen = sorted(words, key=lambda b : len(b))
print(reasen)

numu = [2,4,7,10]
mold = [n*n for n in numu if n > 5]
print(f"hahaha{mold}")

last = [[1,2], [3,4], [5,6]]
metrix = [ nul for lol in last for nul in lol]
print(metrix)
# d for v in x , agian on sorted key=lambda ,in len(i), filter > 6 or % 2 == 0 and (){}[], and map from valabele into fun

# day 41
name = ["bob", "Alice", "yuval", "Charlie"]
okey = (sorted(name, key=lambda x : x.lower()))
print(okey)

deta= [(3, "appel"),(4, "banana"), (1, "kiwi")]
proses = (sorted(deta, key=lambda o: o[0]))
print(proses)

word = ["hi", "python", "awesome","x"]
miria= (sorted(word, key=lambda e : len(e)))
print(miria)

yy = [2,8,1]
yy.sort()
print(yy)

ll= [3, 6, 1, 2, 9]
ll.sort(reverse=True)
print(ll)

wy= ["banana", "kiwi", "appel"]
uy= (sorted(wy , reverse=True))
print(uy)

num =[ 12, 35, 48, 79, 1]
wow = (sorted(num, reverse=True))
print(wow)
# reverse TRue false, sorted, sort, lambda, key and lower ,(), inside, revers=True, all, any

# day 42
num = [3, 8, 11, 4]
results = (any(n > 10 for n in num))
print(results)
nums1 = [4, 7, 19, 1, 6]
result =(all(w % 2 == 0 for w in nums1))
print(result)

my_list = [2, 5, 7]
poor = (list(map(lambda u : u * 3, my_list)))
print(poor)

print(list(map(lambda k: k + 1, [10, 20, 30])))

nums1 = [2, 5, 12, 7, 20]
loor = list(filter(lambda x : x % 2 == 0, nums1))
print(loor)

last = ["appel", "hi", "aa", "code", "watermelon",]
boom = (list(filter(lambda i: len(i)> 3, last)))
print(boom)

more =  [1, 2, 3]
names = ["alice", "bob", "den"]
ages = [20,30,40]
combin =(list(zip(more, names, ages)))
print(f"i told you so {combin}")
# more on filter lambda map and list, zip, print list map lambda in one[] any , and all

# day 43
#%%writefile first_time_ever.txt   next code is ! grap "gorg" first_time_ever.txt or cat
def even_only(numbers):
    pop = []
    for p in numbers:
       if p > 10:
         pop.append(p)
    return pop
print(even_only([3, 12, 22, 7]))

def bigger_then(numbers, limit):
    gorg = []
    for x in numbers:
          if x > limit:
              gorg.append(x)
              continue
    return gorg
print(bigger_then([4, 15, 3,20], 10))

def why(a: str) -> str:#
    ere = []
    for t in a :
       if len(t)> 4:
        ere.append(t)
    return ere
print(why(["hi", "apple", "sun", "banana"]))

act = ["python", "day", "code"]
miu = list(d.upper() for d in act)
print(miu)

soon = ["Alice", "Bob", "Michael", "Ali", "Tom ", "Adam"]
know = (list( d for d in soon if d.startswith("A")))
print(know)

def crying(o):
    count = 0
    for y in o :
        if y % 2 == 0:
           count += y
    return count
print(crying([3, 4, 9, 7, 10]))

yuy = [ 7, 5, 8, 11, 700]
ror = max(yuy)
print(ror)
# what we learn about hacking ant .txt stsrtswith , and upper inside list

# day 44
def scream(haa):
    reasen_p = [x for x in haa if x % 3 == 0]
    return reasen_p
print(scream([3, 4, 5, 6, 7, 9]))

def so_long(y):
    return [w for w in y if len(w) > 4]
print(so_long(["hi", "apple", "sun", "banana"]))

muns = [ 2, 5, 8]
factor = 3
sons = (list(map(lambda k: k * factor, muns)))
print(sons)

pairs = [(v, z) for v in [1, 2] for z in [3, 4, 5]]
print(pairs)

where = [3, 4, 7, 10]
sun_4 = sum([ c for c in where if c % 2 == 0 ])
print(sun_4)
# sum, diffrent things without fun lambda with s * 3 map again,  inner and outside inside list not fun

# 45
again = [ 2, 5, 8, 13, 20]
even = [ n for n in again if n % 2 == 0]
print(even)

idk = [1, 3, 5]
doubl = (list(map(lambda k: k * 2 , idk)))
print(doubl)

haha = ["a", "b"]
space = [1,2,3]
goel = [l + str(n) for l in haha for n in space]###
print(goel)

vals = [4, 7, 10, 15]
nooo = sum([s for s in vals if s % 2 == 0])
print(nooo)

haaaa = ['doron', 'mauor', 'noam', 'bob']
dthe = [w for w in haaaa if len(w)> 4]
print(dthe)
# sum again len ,map and list in lambda , str(t) in innur

# day 46
forget =[3, 6, 9, 12, 15]
results = (list(map(lambda k: k* 2, filter (lambda k: k % 3 == 0 and k > 8, forget))))
print(f"first{results}")

words = ["banana", "apple", "kiwi", "python", "sun"]
idc = [w.upper()for w in words if len(w) > 4]
print(f"who i am{idc}")

agian = ["Alive", "CHarlie", "Bob"]
age  = [ 3, 50, 8]
pol = [(n, a) for n, a in zip (agian, age) if a > 20] ####()()()
print(f" is bigger{pol}")

nora = [[1, 2], [3,4,5],[6]]
flat = [x for y in nora for x in y]
print(f"innur loop{flat}")

last = [2, 5, 10, 15]
d = {n: n*n for n in last if n % 2 == 0}
print(f"normal dicionary {d}")

mor = ["hi", "moran", "abigail", "ball", "python"]
less = [w for w in mor if "o" in w]
print(less)
# diffrent map , zip ,dictonery , innur inside list lambda * 2

# day 47
sons = ["bob", "Alice", "Tom",7]
for (i ,n)  in enumerate(sons):
     print(i, n)

deta = [10, 20, 30]
a, b, c = deta
print(a,b,c)

v, *rest = [100, 1, 2, 3, 4]
print(v, rest)

ops ={"Double": lambda x: x* 2,
      "Square" :lambda x: x * x}###
number = 5
print(ops["Double"](number))
print(ops["Square"](number))

fofo = ["banana", "hi", "wathermelon", "code"]
wowo= (sorted(fofo, key=lambda s: len(s)))
print(wowo)

gog = [10, 2, 33, 7]
nooo = (sorted(gog, key=lambda y: - y ))
print(nooo)
# enumarete for giving order, a,b,c ,h  *rest, dictonery lambda for value , sorted and len, key=lambda -y in sorted like revers=True

# day 48
def make(g):
    def multiply(x):
         return x * g
    return multiply
dool = make(2)
kool = make(3)
print(dool(5))
print(kool(5))

def antismite(nums, rule):
    real = []
    for n in nums:
      if rule(n):
        real.append(n)
    return real
print(antismite([3, 10, 15, 2], lambda x: x > 5))

def do_not_forget(numd, rood):
    list8 = 0
    for w in numd:
      if len(w)> rood:
          list8 += 1
    return list8
print(do_not_forget(["python", "love", "day", "amazing"], 3))

def add(a, b): return a + b
def mul(a, b): return a * b
act = {
    "add": add,
    "mul": mul
}
print(act["add"](3, 4))
print(act["mul"](3, 4))

def even(x): return x % 2 == 0
numy = [3, 4, 8, 11, 20]
print([x for x in numy if even(x)])

def make(i):
    return lambda x : x * i
triple = make(3)
print(triple(7))
# def inside fef, def 2 paramter and lambda in one, 2 def and fiffrent return on a dictonery, def and list rule, return lambda then list and value in print

#day 49
yums = [3, 8, 12, 5, 20]
more = [ v * 2 for v in yums if v > 10]
print(more)

def keep(what):
    roon = []
    for d in what:
      if d[0] in "aeiou":
        roon.append(d.upper())
    return roon
print(keep(["apple", "banana", "orange", "cat"]))

price = {"apple": 3, "banana": 2, "watermelon": 10}
friday = {k: g * 0.8 for k, g in price.items()}
print(friday)

lex = ["Avi", "Ben", "Noah"]
fridman = [17, 22, 15]
adults = [n for (n, w) in zip(lex, fridman)if w > 18]
print(adults)
# lambda inside fun zip, d[0], normal loop insude list

# day 50
def clean_text(wow):
    return wow.strip().lower()
def longer(okey):
    words = clean_text(okey).split()
    count = 0
    for c in words:
       if len(c) > 4:
          count += 1
    return count
print(longer("   Hello PYTHON wolrd coding   "))

def double(i):
    return i * 2
real = double(5)
print(real * 10)

def eve_over(r):
    mad = []
    for t in r:
       if t > 10 and t % 2 == 0:
        mad.append(t)
    return mad
print(eve_over([3, 12, 7, 20, 9, 22]))

def r(o):
    return o.strip().lower()
def k(m):
    return len(r(m).split())
print(k(" HI love Python   "))

def make():
    print("hello")
    return "kpop"
save = make()
print(save)
# the reasen is for ai and how ai working list loop valabeles if and True False how the ai agi brain think and operite why do we need return and not print
# all the weys to outsmart the computer and make it work for me 50 days is done!!!!!!!!!!!!!!!!!!!!

# day 51   AI thinking
def code1(tex):
    return tex.lower().split()
def code2(human):
    return [w for w in human if len(w) > 4]
rodrom = (code2(code1("   Ai learn from massive deta  ")))
print(rodrom)

def clean(text):
    return text.lower().strip()
def numb2(text):
    return text.split()
def long(words):
    count = 0
    for x in words:
      if len(x) > 4:
        count += 1
    return count
def anilz(text):
    return (long(numb2(clean(text))))
print(anilz("  Ai modes learn pattrens fast"))
# how ai think take for this on and this fun and toghter give out put

# day 52
def fol(u):
    return u * 2
def dol(h):
    return  h + 5
print(dol(fol(3)))
# clean> split> analyze

# day 53
def gotf(n):
    more = []
    for w in n:
       if len(w.strip()) > 4:
         more.append(w.strip().lower())
    return more
print(gotf(["Hi", "Python", "shlomo   "   , "   ai"]))

ere = [1, 2, 3, 4]
shur= []
for t in ere:
    shur.append(t * 2)# or if % 2 == 0
print(shur)


tree = [2, 5, 8, 11]
two = []
for c in tree:
  double = c * 2
  if double > 10:
     two.append(double)
print(two)


text = " I Love Python BYe "
agian = text.strip().lower().split()
wrong = []
for x in agian:
   if len(x)> 3:
     wrong.append(x)
print(wrong)
# again ai thinking and nlp to ai give output clean first then split analyze then give answer

# day 54 AI nlp (natural lenguge proses)
def clean_text(text):
    return text.strip().lower() # first we clean the human input

def to_words(text):
    return text.split()# then we split take each word and chacking them

def long_words(words):
    results = []
    for w in words:
       if len(w) > 4: # this part is the fillter to see how many shuld we have
          results.append(w)
    return results

def counts_words(words):
    return len(words)# ^ this one is tell us how many of the fillter do we got

def analyze_text(text):# this if the decison fun that concct everyting thogethr and give output
    cleande = clean_text(text)
    words = to_words(cleande)
    important = long_words(words)
    return counts_words(important)
print(analyze_text("  Hello Python World Coding AI   "))
# this is how ai works small fun and then we return out put and not one big one

#day 55
# input > Transform > decision > output>
def clean(word):
    return word.strip().lower()

def check(word):
    w = clean(word)
    if len(w)> 3:
       return True
    return False
print(check("  HelLo"))

def importent(lol):
    results = []
    for x in lol:
      if len(x) > 4:
        results.append(x)
    return results
print(importent(["HI", "Love ", "To", "Learn", "PYTHON", "and", "Ai"]))

def score(nums):
    total = 0
    for n in nums:
       if n > 5:
         total += n
    return total
print(score([ 1, 4, 6, 8]))
# diffrent fun for ai to make desision and guses what will be the output

# day 56
def hell_on(text):
    return text.lower().strip()
def heven_off(word):
    return len(word)
words = [" AI", "python", "   model"]
scores = []
for w in words:
    k = hell_on(w)
    scores.append(heven_off(k))
print(scores)

scorse = {
    "cat": 3,
    "lion": 8,
    "dog": 3
}
best = (max(scorse, key=scorse.get))
print(best)

nums = [2, 5, 8, 11, 14]
filterd = [ w for w in nums if w > 6]
results = (sum(filterd))
print(results)

words = {"car", "airplain", "train"}
lenghte = { w: len(w) for w in words}
choice = (max(lenghte, key=lenghte.get))# or minimum or just len
print(choice)
# same for Ai thats take value and going theru filters and make decision , .get lets the dictinery control by the spesific value

# day 57
def normal(nums):
    return [n / 10 for n in nums]
def filtar(nums):
    return [ n for n in nums if n > 1]
deta = [5,10,22]
step1 = normal(deta)
step2 = filtar(step1)
print(step2)

def clean(text):
    return text.strip().lower()
def is_greater(words):
    return len(words) > 4
def last(text):
    word = clean(text).split()
    return [ w for w in word if is_greater(w)]
print(last(" Hllo PYTHON  World Coding  "))

def maximum(wol):
    return max(wol,key=len)
print(maximum(["x", "joke", "finesse", "hi"]))

golem = [2, 4, 6]
answer ={k: k*k for k in golem}
print(answer)
# we learn n/ 10 and agian how dose ai oppereat

""" #day 58
python = list | ai = dataset

python = loop | ai = scan data

python = if\elif | ai = decision rule

python = return | ai = model output

python = max/ min | ai = predicion

python = key= | ai = feature importance

ai most to understand the input thats why we heve .lower.strip.split
ai not give the "right answer", but the he predicion one bast an all the parameters
ai work with num not words he dosent ubderstund for him to give the right output he can try lets say the len(words) day 59
"""

# day 59
#ai dosenot work on true false but scores prediction and see if its the most reasen and good respans
def score_word(word):
    return len(word)
words = ["hi", "python", "code", "intellegant"]
score = []
for w in words:
    score.append((w, score_word(w)))
print(score)
# ai dosent say good/bad but how much
def best_word(words):
    best = ""
    goods = 0
    for w in words:
      s = len(w)
      if s > goods:
        best = w
        goods = s
    return best
print(best_word(["hi", "python", "intllegant", " code"])) #s mean len(w) then we looking for the bigest that goods is 0
# this is the decision not "filter"

def word_score(word):
    list2 = 0
    list2 += len(word)
    if "a" in word:
        list2 += 2
    return list2
print(word_score("code"))
print(word_score("deta"))# in case we see "a " we add 2 in len

word = ["ai", "deta", "learning", "model"]
ranked = (sorted(word, key=len,reverse=True))
print(ranked)
# as pf ai heve a lot of prodictis and score not 100 answer like here

# day 60
fkfg = [4,7,4,8,1,9,3]
print(fkfg.index(1))# simmple index

cand = ["cat", "dog", "mause"]
scorse = [0.5, 0.3, 0.6]
best = cand[scorse.index(max(scorse))]
print(best)
# its imprtent for ai as he try to give the resanbol answer bast on the stats heven if dog more resanbol still the score was bigger
skf =["kiwi", "apple", "banana"]
psi = [0.7, 0.5, 0.2]
pool = skf[psi.index(min(psi))]
print(pool)# same as ai its not corecct but confidens of the results he can still make mistake

# day 61
dif = [1,10, 66, 2, 40, 3, 4, 5]
rkf = (list(filter(lambda k: k % 3 == 0 and k > 10,dif)))
print(rkf)

word = ["appele", "banana", "kiwi"]
leng = (list(map(len,word)))
print(leng)

owo = ["bob", "Alice", "Charlie"]
dfrr = [54, 98, 76]
combo = (list(zip(owo,dfrr)))
print(combo)

dod = ["appele", "bananalol", "kiwi"]
gog = (max(dod,key=len))
print(gog)

agian = ["ai", "model", "intellegant","python"]
scorse = {}
for w in agian:
   scorse[w] = len(w)
print(scorse)

agian = ["ai", "model", "intellegant","python"]
scorse = {}
for w in agian:
    list1 = len(w)
    list2 = sum(1 for c in w if c in "aeiou")
    scorse[w] = list1 + list2
print(scorse)
#feturse and voweles and len sum 1

# day 62
words = ["ai", "learning", "model", "intelligence"]
scores = {}
for w in words:
    length_score = len(w)
    vowel_score = sum(1 for c in w if c in "aeiou")
    scores[w] = length_score + vowel_score
best_word = max(scores, key=scores.get)
nooo = scores[best_word]
print(nooo, best_word)# aremax its humen decisen

trying = "ai is cool", "machin learning is powerful", "hi"
dictator ={}
for v in trying:
   dictator[v] = len(v.split())
win = (max(dictator, key=dictator.get))
print(win)
ror = [2, 5, 7, 9]
print(sum(ror))

hi = {"A": 0.51, "b":0.49}
bye = (max(hi, key=hi.get))
print(bye)
# ai decisen and argmax

# day 63
idk = ["apple", "banana", "kiwi", "grape"]
know = {w: len(w) for w in idk}
print(know)
nums = [2, 5, 8, 11]
doubles = (list(map(lambda x: x * 2, nums)))
print(doubles)
name = ["ali", "shlomo", "abi", "joseph"]
score = [n for n in name if len(n) > 3]
print(score)
wow = [345, 567, 879]
okey = (sorted(wow, reverse=True))
print(okey)
rot = ["a", "b", "c"]
gone = {i: tor for i,tor in enumerate(rot)}
print(gone)
gone = ["Alice", "Bob"]
game = [45, 65]
ddfo = (dict(zip(gone, game)))
print(ddfo)
# diffrent fun in list dict , zip str, map

# day 64- 71
# scores and confidance
scores = {
    "ai": 2,
    "learning": 8,
    "model": 5,
    "intelligence": 12
}
start = (sum(scores.values()))
coon = {}
for w ,m in scores.items():
     coon[w] = m / start
best_word = (max(coon, key=coon.get))
maga_word = coon[best_word]
print(best_word, maga_word)

scores = {
    "ai": 2,
    "learning": 8,
    "model": 5,
    "intelligence": 12
}
start = (sum(scores.values()))
coon = {}
for w ,m in scores.items():
     coon[w] = m / start
print(coon)
# 1/ 3 = 0,333 devid always 1 is the one we will brake to the pices of the ather num here is 3 which mean how many pic will be in this num left to right
# its importent in ai for even if we have big num stil dosent meter we whant to know comper to ather how big he is and with ather small fun

# day 72 - 78
hello = ["ai","learning", "model","intelligence"] #aggregation
ma = {b: len(b) for b in hello}
now = (sum(ma.values()))
goor = {}
for x, v in ma.items():
    goor[x] = v / now # normalizaition
last = (max(goor, key=goor.get))#decision ,argmax
prom = goor[last]
print(last, prom)

miami = ["ai","learning", "model","intelligence"]
da = {y: len(y) for y in miami}
later = (sum(da.values()))
noww = {s: d / later for s, d in da.items()}# make it smaller for ai as a loop inside list
most = (max(noww, key=noww.get))
print(most)

def clav(red):
    return red.lower().strip()
def adin(red):
    words = clav(red).split()
    return len([w for w in words if len(w) > 4])
print(adin("  HI how ARE YOU doing today  "))

rig = ["alice", "bob", "charlie"]
gir = (list(map(str.upper, rig)))
print(gir)

action = ["hi", "michel", "ai", "abigail"]
poor = { g: len(g) for g in action}
sors = {r: f for r,f in poor.items() if f > 2}
print(sors)
# how ai brain work and diffrent scorse for / items valus get max str, list

# day 79 - 80
input = "  HI Humans are SO diffrent from ai "
clean = input.lower().strip().split()
nlp = {f: len(f) for f in clean}
normal = (sum(nlp.values()))
decision = {g: j / normal for g, j in nlp.items()}
print(decision)
argmax = (max(decision, key=decision.get))
output = decision[argmax]
print(argmax, output)

new = {
   "length": 4,
   "frequncey": 3,
   "context": 2,
   "recency": 1}
trying = (sum(new.values()))
ok = {}
for k, v  in new.items():
    ok[k]= v / trying
print(ok)
last = (max(ok,key=ok.get))
real = ok[last]# [] his the key but the importent part here is the "ok" for the value
print(last, real)
# diffrent ways for ai to first clean then score normalize then argmax then decision lots of gpu like this one ;)

# day 81 - 82
# ai ; baset of the higest scores thats will be and good for the output agian not True but nums and brobeblity
# model state = after he seen words thats allredy egsist he check for ather tokens and the one most higa num that conect to him
# ai dose not remember but work by wights of every num in score that use the most thats the one is going to win even if its incorect
# (rendomnes) tempeture is for the ai not to be repetitiv if its always the high score it alwyse be the same and boring thats why we heve low medium and high tem to not alwyse be the first choise but 2,3
# words> tokens> nums > math
# python has is on toolkis allready that you can use %s math , rendom sqft so on you can from and import from file to file
# sempling
import random
words = ["hello","hi", "hey"]
ghts = [0.6, 0.3, 0.1]
choie = random.choices(words, weights=ghts)[0]
print(choie)
import math
print(math.sqrt(16))# neded from when you want spesific fun from %s
# import conect to ai temp so chosing difrent answers not onley the argmax rendomnss, and ai dosnt ansewr difrent as a magic but temp rendomnes

# day 83
hope = ["apple", "banana", "watermalon"]
suit = {d:len(d) for d in hope}
argmax = (max(suit, key=suit.get))
total = (sum(suit.values()))
more = {}
for word, num in suit.items():
    more[word] = num / total
print(more, argmax)
import random
choise = list(suit.keys())
wei = list(suit.values())
last = random.choices(choise, weights=wei)[0]
print(last)

import random
print(random.choice([1,3,5]))# simpel random toolkit

import random
one = ["yes", "no"]
two = [10, 3]
print(random.choices(one, weights=two)[0])
import random
gyg = {"one": 4,
       "two": 1}
print(random.choices(list(gyg.keys()), weights=list(gyg.values()))[0])
# the reasen random so importent for ai is the randomnas and temp of not aley use argmax and give the same output all the time
# randomnes only start in ai after clean and scoring not befornot in pattron as well

# day 84 - 85
# we learn so far we get input then we clean then we score then we comper then argmax and that argmax alone not alweys good as we dont whant same answer all times
# so we heve temps and rendomness to controll it.
input = "HI sir how are you doing  "
more = {m : len(m) for m in input.strip().lower().split()}
after = sum(more.values())
doct = {}
for w, t in more.items():
    doct[w] = t / after
argmax = max(doct, key=doct.get)
finish = doct[argmax]
import random
one =(list(doct.keys()))
two = (list(doct.values()))
print(random.choices(one, weights=two)[0])# so here we have temp heven doing its the argmax to not be rappetitiv
# llm large,lengueg, model thats get the ai to prodict the next word after scoring temps scale softmax probabilty, then argmax ,next word that
# agian ai dose get tokens and see nums not words if so it score then softmax to prodict of cores bast on tems he on then sempling or argmax bast on the system decision

#day 86 - 89
# just recup getinig the tems right for understandboll chat then we softmax after rew score and then prodict then we argmax or sempling based on tem
# tokens= as the ai dont understand words but nums every word heve value of nums then the prediction come and the tems give us range of what can we decid argmax or semping
# temp = 0.1, very low almost same answer each time temp 0.8= very high can be unprdictbol temp 0.7/0.6 the natural pess that give more opsion but heve priorety for the prdiction
import random
words = ["cat", "dog", "mouse","elephant"]
probability = [0.5, 0.3, 0.15,  0.05]

argmax_choise = words[probability.index(max(probability))]
print("argmax:", argmax_choise)# argmax semple

def simple_word(words, probs):
    r = random.random()
    cumulaitiv = 0
    for word, p in zip(words, probs):
        cumulaitiv += p
        if r <= cumulaitiv:
           return word
sampling_choise = simple_word(words, probability)
print("sampling choies:", sampling_choise)# sempling difrent answers not max
# temp exmple
temp = 0.7# 0.7 middele, 0,1 low, 0.9 high
ajustmant = [p**(1/temp) for p in probability]
total = sum(ajustmant)
ajustmant = [p / total for p in ajustmant]
sct = simple_word(words, ajustmant)
print("temp exemple:", sct)# here you control your sempling unlike def history you give the p**1/ in temp of 7 and let you control it
# how do we do themp argmax and levels of temps random.random, index max, p** (1/temp)

# day 90 - 95
# when we heve a input of math lets say 7 * 5 then we need argmax the only one corect answer when its a story or creaitiv we used sampling and mid/high temp
# its not only the input who decid but more on the system that control the chat

# so we heve input then detaction then we choose if argmax or sempling and the temp then the ai genarat response DECISION LAYER
# sempling is to not give only one response but based on date 0.0 then the temp give the value of the list for what and how will be present
# ai never chose but read system rulse then user requast then he apply the settings in his range and genarate tokens

# the system decaids argmax, sempling, temp and saifty limitsjs
# why model system so importent for the model alweys give corectnes mean output based on the input and can be wrong and denguras thet why we need this dynamc
# of the system to intervin give us idk , please ask someone control the model in diffrent weys
# so the model will alwyse be confident based on probability thats why the system so importent

# user > system > model >sampling > output
# the model get what should he put out by the system in math he tell him low temp and so on the rulse is the systm we dont put rulse inside of model why?
# model is a uge brain to put rulse will be unaffisent and risky lot of money and can be push by probablity as we need to be strick and so on
# model is tons of gpu cpu so on and it can take a lot to chanc it thats why we heve system thats control model

# the big model dosent know what to do or understand untill the system let him know what is allwod what not so after he get respans he start his math
# prompsts is the text that get sand the input so you give it to systam then if its in rulse and prmpts in crativity probability its going in this diraction by the model

# day 96 - 98
import random# devided = split       # natural temp (mid)
original = [0.1, 0.4, 0.6]
cold = 0.7
temp_place = [p**(1 / cold) for p in original]
mum = (sum(temp_place))
conect = [p / mum for p in temp_place]
val = random.random()
lul = 0
for i, p in enumerate(conect):
    lul += p
    if val <= lul:
       choice = i
       break
print(choice)

hello =  [0.1, 0.4, 0.6]            # low tempture
temp = 0.1
weel = [p**(1/temp)for p in hello]
know = (sum(weel))
dis = [p / know for p in weel]
rome = random.random()
fine = 0
for y ,p in enumerate(dis):
    fine += p
    if rome <= fine:
       idk = y
       break
print(idk)

jojo = [0.1, 0.4, 0.6]               # high tempture
dodo = 2
cell = [x**(1 / dodo) for x in jojo]
sums = (sum(cell))
nuro = [x / sums for x in cell]
klam = random.random()
loom = 0
for q, x in enumerate(nuro):
     loom += x
     if klam <= loom:
        love = q
        break
print(love)
# you still dont get the math but the consept you do still need to understand how not only why wich you got we need argmax , sempling and temp control the how rendom the choose of words going to be

#  day 99 - 100
# so we heve the token then the model chang it to nums and prodict the next word which colld decoder then the system check rulse and output
# tokens not read by ther words ai dont know words but num thats why he can read "hell" [he, ll, o] and then like that
# embeddings = token with meining without it difficalt we need structer
#exmple {
#   dog : [0.12, 0.44, 0.91 ]
#  cat : [0.11, 0.40, 0.89]
#  car : [0.30, 0.05, 0.60 ]
#}
# we see same word len but closer conection for pet this is embedding get sturcter and reltivity for closer word help us to prodict tokens
import random
name =["ali", "ahmad", "noor"]
age  = [0.25, 0.59, 0.84]
doro = name[age.index(max(age))]
temp = 2
mail = [p**(1 /temp) for p in age]
gdol = (sum(mail))
nok = [p /gdol for p in mail]
weel = random.random()
zero = 0
for x, c in zip(name, nok):
    zero += c
    if weel <= zero:
       hate = x
       break
print(hate)
print(doro)
print(0.25**0.5,0.59**0.5,0.84**0.5)# high
print(0.25**10,0.59**10,0.84**10)# its -7, low
print(0.25**1.47,0.59**1.47,0.84**1.47)#mid
print(1/0.7)

"""day 101 - 105 - text

so we cover how the modele heve to heve structer embeddings reltivity to get the one closer to each other now we going to learn similarty and reltivity so when we heve cat animal and pet will be closer then car or train, bank = money and finenc and so on the imbededd wil give represent to what it close to him bast on math and so on and if so the model do is thing probabilty so on then after the sempling choose the word next word,


if so we heve tokens the text then go throu embedding(vactors) then run into model after he gets more clear then then the model heve logits raw nums to start is math then after we get the soft max that lets us know how far are the numm from each other in the list they get sum from 0 to 1 then after that we heve temps that control what type of tem do we want low mid high

importent !!
the temp is not new words but control the posibol of other word in the list P**(1 /temp) if its low 0.5 the big in the list become biger if mid 0.7 so the high still go up but other two high 0.9 or 2 nums the high become smaller  1/ 2 = 0.5 and so for the temp what mean more crativ mode and not argmax at all
if so when we heve 1 / low temp 0.5 its devided to two then p 0.42 in power of 2 = 0.21
last = allin one mid low and high and ** where it in 0 to 1 things are for less then 1 become bigger and less distans if bigger become mach far from eachother and far awey and become likely argmax

then come rendomnass random.random() after we gets the right tempo and we gets random nums we see what num is in the random the first one  to and he gets choose

day 106 - text

we learn the all proses of ai the model and system and the map of embedding first we get tokens the input then come into logits after embedding then we do softmax that leed us into probabilty then we heve temp then we have fempling or argmax

now we learn about halluciinate in ai , in ai thare is no i dont know even if not enagh informaision or same nums the model still will give output the llm iss not serch but check for probability thats why he alweys give answer unlike ani its allweys wil give output heven if wrong
thats why the systam so importent to heve rules and inforse the wey the model can run

as we keep going the model is not one antaty of smartness and only it if so hallucinesion incress if so he use diffrent tools for difrent things and all those things get togheter and give resanball output

so we get why we need not only the model more of it think off the ai as agent not useing only the model but diffrent things api web search database caculator and so on big diffrent if only the model do all the job and he chosse what where what tools i need here and so on fact check also importent and loop to verify the get feedbeack

AI company davided the proses to 5 layers
1, Ui = the app it self api and the website
2, system layer = rulse promision temps limits what tools to use
3, agent layer = loop search planing
4, model layer = tokens embedding probability sempling so on
5, inferstructure = gpu, chips data center

day 107 - 110 -text

we go more on how and why the wey of the model to talk to the system calld json meaning a format a coputer can understand eachother and comunicet its kinda like dectonery in pyton with keys and valuse by let the model give the right format to the system he can decide better and do things by his on without human intefirenc for exmple if we heve all what riquier for refound and the set of keys the system can pay back and help in offisent wey thats why json so importent

exmple of pipline the human input then the system take it into json give to the model he understand and give is asasmant then go back to the system and only the system the one who decide and make decision based on the model conclusion

and now we will create anexmple
"""

# day 107 - 110
import json
def first_try(text):
    text = text.lower()
    if "love" in text or "great" in text:
      return {"words": "positive","temp": 0.9}
    if "hate" in text or "bad" in text:
      return {"words": "negetive","temp": 0.9}
    return {"words": "natural", "temp": 0.5}
print(first_try("i Hate you"))
print(first_try("i love YOU"))
print(first_try("i adore You"))# thise is exmple of json for model system and how he put everyting in category

def system_pipline(user_input):
    clean_text = user_input.strip()

    model_output = first_try(clean_text)
    if model_output["words"] == "negetive":
       return {
           "action": "flag",
           "reason": "negetive satelment detected",
           "model_output": model_output
       }
    return {
        "action": "allow",
        "reason": "safe contct",
        "model_output": model_output
    }
doer = system_pipline("i Hate you")
print(json.dumps(doer, indent=2))
print(system_pipline("i Hate you"))
print(system_pipline("i love YOU"))
print(system_pipline("i adore You"))# pipline of json from model system and what rule anyone heve its not the real ai but enxmple

""" day 111 - 115 - text

there some weys of the system to decide if we can trust the model job or not to know if he right wrong and provent wrong and hallusinesions
1, threshold = it anumber we give if the model get to the num we exsept the model work (def theshold)
next we heve fallback e,g, when a confindent is low we give unsure answer and ask for the other model to try and or give more carefull output like the out put will be please ask your friend im not sure if a,z is corect
(def system)
"""

# day 111 - 115
def theshold(answer, confidente, threshold=0.7):# threshold
    if confidente >= threshold:
      return answer
    else:
      return "i cant help you here"
print(theshold("paris is the capitol of france", 0.87))
print(theshold("london is the capitol of germany", 0.45))

def system(answer, confidente):#fallback
    if confidente >= 0.8:
        return answer
    if confidente >= 0.5:
       return "im not sure if im 100 right but here is the response " + answer
    else:
       return "i dont knew without more informision"
print(system("how long will it be", 0.6))
print(system("ai i right", 0.4))

"""day 116 - text

there is only one way as we said we getting the input first come to system and check if it okey for rulse and so on then model make scores probability and so on then come to the system agian and we chacking agian then the threshold then fallback of sorry i cant answer that or please give me more informision or the answer this is not ai this engeniring the model just do part of the job
as we keep going for a ai resultse we need more then one model he can be unreliaieboll and make mistake so we heve multi model verification so we give a model then it go thru anther model then the system decide one for conident answer then it go thru anther model to verify and check then the system looke at it and decide if its good like we said threshold or fallback

last thing the piplin get your qustion and after the sysstem sand to the model he decide if we need onther model or no for many difrent reasens then the system looking at it and decide confident threshold or fallbeack

onther thing to remember is the voting mjorety e.g, we heve more then one models and 2 say high confindence we going withthem even if 3 one say low this is majority voting by all the models how high is the confindent

"""

# day 116
# exmple of ai pipline
import re
import json

# 1) Clean / normalize user input (system step)
def clean_text(text: str) -> str:
    text = text.strip()
    text = re.sub(r"\s+", " ", text)   # collapse spaces
    return text

# 2) Route the request (system decides what kind of task this is)
def route(text: str) -> str:
    t = text.lower()
    if any(word in t for word in ["refund", "charged", "billing", "payment", "cancelled"]):
        return "billing"
    if any(word in t for word in ["crash", "bug", "error", "not working", "freeze"]):
        return "technical"
    return "general"

# 3) "Model" (placeholder): returns an answer + a confidence score (0.01.0)
# Later we will replace this with a real model call.
def fake_model(task: str, text: str) -> dict:
    if task == "billing":
        return {"answer": "I can help with billing. What was the charge date and amount?", "confidence": 0.75}
    if task == "technical":
        return {"answer": "I can help troubleshoot. What device and what error message do you see?", "confidence": 0.70}
    return {"answer": "Tell me a bit more about what youre trying to do.", "confidence": 0.60}

# 4) Fallback (system safety net)
def fallback(task: str) -> dict:
    return {"answer": f"Im not confident yet. Please add one detail about your {task} issue.", "confidence": 0.30}

# 5) The pipeline (everything together)
def run_pipeline(user_text: str) -> dict:
    cleaned = clean_text(user_text)
    task = route(cleaned)
    model_out = fake_model(task, cleaned)
    # system rule: if confidence is low, fallback
    if model_out["confidence"] < 0.65:
        model_out = fallback(task)

    final = {
        "task": task,
        "cleaned_input": cleaned,
        "answer": model_out["answer"],
        "confidence": model_out["confidence"],
    }
    return final
result = run_pipeline("  I was charged twice this month. refund please  ")
print(json.dumps(result, indent=2))
result = run_pipeline("  my dog just bite me  ")
print(json.dumps(result, indent=2))

"""day 117 - 119

MAJORTY VOTING:
we heve diffrent models as we said first as the chip one fast then model b sollower and stronger then the model that verify and so on we need more then one model after we see the num of confindence and this is how we getting gpt answer good ai answer of corse the ony who is in charge is the system

AI TOOLS:
as we said the model only predict  and give answer but not act this is on the system who decide so lets say you need somting from a company you give input get to the system but in a category sand to the model his do his thing sand back to the system to decide like give back money and so on this is tools of ai

AI FAILURE & GUARDRAILS:

somting can always go wrong with the model system tools like data and so on a system can always try to check agian if still somting not go right we heve fallback not to give wrong respunse

LOGGING & OBSORVBILITY & ODUITS:
log is evey step of ai pipline do somthing calld log whan we want to see if ai dosent work we lookinng on every step of every tool and this is loginng what come to where and who same for obsorvde whaen somting dont work we need to  see what where if is this model system agent specific tool and so on the oduit its the maskna of what the probloms are

DAY 120 - 124

monitor , matrix , failers;


we need for a error not only one but many and from how many 5% 10% so on tho see from what and how for the model as well we check is corectnes vs the true if the con high and corect as hell this is the ideal if is high but fallse thats dengarus why becouase the system cant corect it after he got high con so output bad will be inevdtball low and corect ok but we need the model to be sure low and not con thats exspact falier this is how we check the model and if it accselly work this why system is importent not only thats but for moniter over tome whare the model crate probloms how many of day what kind of things he heve probloms with

drift ;

after yesrs the model can becoume no good do to the change of human input difrent data nd so on nothing stay the same and it true as well for ai

evalition:

we heve offline and online offline is you try to see if all good online is with users what are the feedback of the model checking the confindent and corectnes its still could be wrong we see how the model work with or without users its on the model part the evalution

A/B testing :

the pipline can learn a lot from user usedge as of giving diffrent answer in same input to two diffrent users and see wich one give better feedback its not but can be diffrent model difrent system and so on  but not use for decision of corse only in the prosese

prompts:

are always better whaen they are clear and can give better to the model but his part of the pipline so small the big one is the system who decleare temp tools rulse and so on so it dosent really metter
"""

# day 125 - 126
import json
# the over all exmple of my ai pipline
user_dhh = "i was charged twice this month"
def clean_input(text):
    return text.lower().strip()
cleaned = clean_input(user_dhh)

def route_tesk(text):# system
    if "charged" in text or "refund" in text:
       return "billing"
    if "error" in text or "crash" in text:
       return "technical"
    return "genarel"
task = route_tesk(cleaned)
def model(task):#model
    confidence_map = {
          "billing": 0.83,
          "technical":0.78,
          "genarel": 0.55

          }
    return confidence_map.get(task, 0.40)
confidence = model(task)
def system_check(task, confidence):# fallback
    if confidence < 0.6:
       return {
           "status":"fallback",
           "messege": "need more informision",
          }
    return {
          "status": "ok",
          "category": task,
         "confidence": confidence
             }
results = system_check(task, confidence)
print(json.dumps(results, indent=2))

# day 127
import json# we see here what is log /n, datetime and memory
from datetime import datetime
# MEMORY (short-term)
memory = []
# LOGGING
def log_event(stage, data):
    entry = {
        "time": datetime.utcnow().isoformat(),
        "stage": stage,
        "data": data
    }
    print(json.dumps(entry, indent=2))
# CLEAN INPUT
def clean_input(text):
    return text.lower().strip()
# ROUTING (system logic)
def route_task(text):
    if "charged" in text or "refund" in text:
        return "billing"
    if "error" in text or "crash" in text:
        return "technical"
    return "unknown"
# MODEL (mocked)
def model_confidence(task):
    scores = {
        "billing": 0.85,
        "technical": 0.78,
        "unknown": 0.40
    }
    return scores.get(task, 0.30)
# SYSTEM DECISION
def system_decision(task, confidence):
    if confidence < 0.6:
        return {
            "status": "fallback",
            "message": "Need more information"
        }
    return {
        "status": "ok",
        "category": task,
        "confidence": confidence
    }
# PIPELINE (THE BRAIN)
def handle_user_input(user_input):
    # store memory
    memory.append(user_input)

    log_event("raw_input", user_input)

    cleaned = clean_input(user_input)
    log_event("cleaned_input", cleaned)

    task = route_task(cleaned)
    log_event("routed_task", task)

    confidence = model_confidence(task)
    log_event("model_confidence", confidence)

    decision = system_decision(task, confidence)
    log_event("system_decision", decision)

    return decision
response = handle_user_input("I was charged twice this month")
print("\nFINAL RESPONSE:")
print(json.dumps(response, indent=2))
print(memory)

"""day 128 - text


logs & events(metrix), and memory:

in an AI system, after understanding the basic pipeline of input  system  model  system  output, there are several invisible layers that make the whole thing reliable, scalable, and safe: logs, events, memory, and metrics. Logs are a detailed internal record of what the system did and when it did it (timestamps, routing decisions, confidence levels, fallbacks, errors). Logs are not for users and usually do not store personal input, but are used by engineers for debugging, auditing, performance analysis, and improving the system latersimilar to CCTV footage that you only check when something goes wrong. Events are real-time signals that something important happened (for example:

 fallback triggered, low confidence detected
second model invoked), and they help the system or engineers react immediately, monitor health, or trigger alerts. Memory is different: it exists to maintain continuity for the user experience, remembering previous turns in a conversation or relevant context so the system can respond consistently, but it is controlled by the system and not the model itself. Metrics are aggregated numerical measurements (like average confidence, fallback rate, latency, error frequency, temperature usage) that show how the system behaves over time; they help teams understand trends and make data-driven decisions. Importantly, none of these components change the models math directlythe model only produces probabilitiesbut they allow the system to supervise, verify, reroute, or stop outputs when needed. Together, logs explain what happened,

events show what is happening now, memory preserves context, and metrics reveal long-term behavior, enabling the AI pipeline to function safely, transparently, and at scale, even when millions of users interact with it simultaneously.


(memory imprtent for long term of the chat and get save in session)
"""

# day 128
import time
import json
memory = []
def log(level, message):
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S") # Added a format string here
    print(f"[{level}] {timestamp} - {message}")

def clean_input(text):
    log("INFO", "Cleaning input")
    return text.lower().strip()

def route(text):
    if "refund" in text or "charged" in text:
        log("INFO", "Routed to BILLING")
        return "billing"
    log("INFO", "Routed to GENERAL")
    return "general"

def model(task):
    scores = {
        "billing": 0.82,
        "general": 0.55
    }
    confidence = scores.get(task, 0.4)
    log("INFO", f"Model confidence = {confidence}")
    return confidence

def system_decision(task, confidence):
    if confidence < 0.6:
        log("WARNING", "Low confidence  fallback triggered")
        return {
            "status": "fallback",
            "message": "Need more information"
        }
    log("INFO", "Response approved")
    return {
        "status": "ok",
        "category": task,
        "confidence": confidence
    }
user_input = "I was charged twice this month"
memory.append(user_input)
cleaned = clean_input(user_input)
task = route(cleaned)
confidence = model(task)
result = system_decision(task, confidence)

print("\nFINAL OUTPUT:")
print(json.dumps(result, indent=2))
print(memory)

# day 129 - 130
import uuid
import json
# Session + Memory Storage
SESSIONS = {}
def get_session():
    session_id = str(uuid.uuid4())
    SESSIONS[session_id] = {
        "memory": [],
        "history": []
    }
    return session_id

def clean_input(text):
    return text.lower().strip()
# Routing
def route_task(text):
    if "charged" in text or "refund" in text:
        return "billing"
    if "error" in text or "crash" in text:
        return "technical"
    return "general"
# Model (mock)
def model_predict(task):
    scores = {
        "billing": 0.85,
        "technical": 0.75,
        "general": 0.50
    }
    return scores.get(task, 0.40)
# System Decision Layer
def system_decide(task, confidence):
    if confidence < 0.6:
        return {
            "status": "fallback",
            "message": "I need more information to help you."
        }

    return {
        "status": "ok",
        "category": task,
        "confidence": confidence
    }
def handle_request(session_id, user_input):
    cleaned = clean_input(user_input)
    task = route_task(cleaned)
    confidence = model_predict(task)
    decision = system_decide(task, confidence)
# Memory update (system decides what to store)
    SESSIONS[session_id]["history"].append(user_input)
    if decision["status"] == "ok":
        SESSIONS[session_id]["memory"].append(task)
    return decision
session = get_session()
result = handle_request(session, "I was charged twice this month")
print(json.dumps(result, indent=2))
print(SESSIONS)

"""day 131 - 132

tools ;

the sysrem is the one who is in charge not the model he only say what type of model or text we need here so if we need to give money back he get it in category and say in json he need to get pay back and what type of tool do we need then the system going and make the call get the tool and give the answer or the money back to the user

rout:
the simple one is with if / for but when we whant to scele and add more we make it in {} key and valuse and we can odd more key and then argmax the value
"""

# Day 131-132 - Full AI-style Task Router (Data-driven scoring)
ROUTES = {
    "billing": ["charged", "refund", "payment", "invoice"],
    "technical": ["error", "crash", "bug", "not working"],
    "account": ["login", "password", "email", "locked"],
    "shipping": ["delivery", "late", "tracking", "shipment"]
}
def clean_input(text):
    return text.lower().strip()
def score_routes(text):
    scores = {}
    for category, keywords in ROUTES.items():
        score = 0
        for word in keywords:
            if word in text:
                score += 1
        scores[category] = score
    return scores
def choose_category(scores):
    return max(scores, key=scores.get) # argmax

def route_text(user_text):
    cleaned = clean_input(user_text)
    scores = score_routes(cleaned)
    category = choose_category(scores)
    return cleaned, scores, category

# ---- TESTS ----
tests = [
    "I was charged twice this month, refund please",
    "The app crash and shows an error",
    "I forgot my password and can't login",
    "My delivery is late and I need tracking"
]

for t in tests:
    cleaned, scores, category = route_text(t)
    print("INPUT:", t)
    print("CLEAN:", cleaned)
    print("SCORES:", scores)
    print("CATEGORY:", category)
    print("-" * 40)

# day 133
import json
def clean_input(text):
    return text.lower().strip()

def route_text(text):
    scores = {
        "billing": 0,
        "technical": 0,
        "general": 0
    }
    keywords = {
        "billing": ["charged", "refund", "invoice"],
        "technical": ["error", "crash", "bug"],
        "general": ["login", "account", "password"]
    }

    for category, words in keywords.items():
        for w in words:
            if w in text:
                scores[category] += 1

    chosen = max(scores, key=scores.get)
    return scores, chosen
# -------- MODEL --------
def model_confidence(category):
    confidence_map = {
        "billing": 0.83,
        "technical": 0.76,
        "general": 0.55
    }
    return confidence_map.get(category, 0.4)

#  SYSTEM DECISION
def system_decision(category, confidence):
    if confidence < 0.6:
        return {
            "status": "fallback",
            "message": "Need more information"
        }

    return {
        "status": "ok",
        "category": category,
        "confidence": confidence
    }

def handle_request(user_text):
    cleaned = clean_input(user_text)
    scores, category = route_text(cleaned)
    confidence = model_confidence(category)
    result = system_decision(category, confidence)

    return {
        "input": user_text,
        "cleaned": cleaned,
        "scores": scores,
        "decision": result
    }
response = handle_request("I was charged twice this month")
print(json.dumps(response, indent=2))

"""day 134 - 135 text

we learn what is file and after is you want you import file name and the name of the fun you want %%writefile .py is for work coding txt. more for noths and history logs so on

git/(github):

git its a tool(pogram) that let you run the code you did and by remember every commit(change) you did to the code the key if after you change the code and can give error git can let you go back (rollback) and help you the mode your code in better way without do it all over agian github is the web site you can use the tool git show your code in the comunity and so on

git init - its when you put it in the file
git status - its show you what append
git add . - you add your fun tho git to remember
git commit -m "first commit"- you give him your chackpoint what you change in safe way

day 136 - 137 text

git init         start tracking
git status       see changes
git diff         inspect changes
git add          choose what to save
git commit       save snapshot
git log          view history

Git is a version-control tool that tracks file changes over time by first initializing a repository with git init, then checking file state with git status, selecting changes to save using git add, permanently recording snapshots with git commit -m, viewing history with git log, comparing changes with git diff, and allowing safe rollback in three main waysgit checkout <file> to undo unstaged changes, git reset --hard <commit> to return the entire project to an earlier commit, or git revert <commit> to create a new commit that cancels a bad onewhile GitHub is only a website that stores these Git histories remotely and shows commits but does not teach Git unless you run the commands yourself.

day 138 - 142 text

i did first the github acount then i start learn the git tool itself on linex we donlowed the nano the creat my project calld ai_project then creat a file pipline.py then we import the git init then we git add . to the file we put a route fun system and run the file python3 pipeline.py
we change and did git diff to see the changes check status and see free tree then we make on same file the all ai pipline and log with a git .log to see the log and let me do input on the terminal we seen the commit and give it a name

git ignore :   
its for make a file that every file with .log will be not in git fun as we said we dont need git but to code and remember for action logs are for informition not to change then we add the file comit and boom its work now we heve file nano for code more slow and better for code like python and we heve echo simple and fast for somthing like logs

going back:

there is 3 ways for you to go back in case of bug in a code befor you commit you check the code and see that its wrong
1 = git restore . and the name of the file after you check status and see the diff befor commit
2 = git reset --hard HEAD~1 this one is after you commit and you want to delat it and keep the rest so the code will be good you reset the name
3 =(reverse. let you change in history the commit to onther one without dalet the wrong commit) git checkout e4f5g6h it exmple of old commit you want to delat so you do it and then= git checkout main  and its cancel the error one in the one the good befor it and all good

.env:

is enviermant valable is to keep api keys secret not on the code and for passwords like .log we dont want the git to use it so we put every.env in the ignore lits in the code we import os and then we put in file the value and the key in the code and pepele dont know the secrats
"""

import os
import json
import logging
import uuid
from datetime import datetime
import builtins # Import builtins module

# LOGGING SETUP
LOG_FILE = "pipeline.log"

logger = logging.getLogger("pipeline")
logger.setLevel(logging.INFO)

# Avoid duplicate handlers if you run the file multiple times in same session
if not logger.handlers:
    file_handler = logging.FileHandler(LOG_FILE)
    file_handler.setLevel(logging.INFO)

    formatter = logging.Formatter(
        fmt="%(asctime)s | %(levelname)s | %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

def clean_input(text: str) -> str:
    return text.lower().strip()

def route_task(text: str) -> str:
    if "charged" in text or "refund" in text or "invoice" in text:
        return "billing"
    if "error" in text or "crash" in text or "bug" in text:
        return "technical"
    return "unknown"

def model_confidence(task: str) -> float:
    confidence_map = {
        "billing": 0.85,
        "technical": 0.78,
        "unknown": 0.45
    }
    return confidence_map.get(task, 0.40)

def system_check(task: str, confidence: float) -> dict:
    # System safety/decision layer
    if confidence < 0.60:
        return {
            "status": "fallback",
    "message": "Need more information to help safely.",
            "category": task,
            "confidence": confidence
        }

    return {
        "status": "ok",
        "category": task,
        "confidence": confidence
    }
# ONE REQUEST RUN
def handle_request(user_text: str) -> dict:
    request_id = str(uuid.uuid4())[:8]  # short id for readability

    logger.info(f"[{request_id}] START request")
    logger.info(f"[{request_id}] raw_input={user_text!r}")

    cleaned = clean_input(user_text)
    logger.info(f"[{request_id}] cleaned_input={cleaned!r}")

    task = route_task(cleaned)
    logger.info(f"[{request_id}] routed_task={task}")

    conf = model_confidence(task)
    logger.info(f"[{request_id}] model_confidence={conf}")

    result = system_check(task, conf)
    logger.info(f"[{request_id}] system_result={result}")

    logger.info(f"[{request_id}] END request")
    return result
# MAIN (RUN)
if __name__ == "__main__":
    # Use builtins.input to avoid conflicts with shadowed 'input' variables
    user_text = builtins.input("Type a message (example: 'I was charged twice'):\n> ")
    result = handle_request(user_text)

    print(json.dumps(result, indent=2))
    print(f"\n(Log saved to {LOG_FILE})")
# we did the os import as well with the env. file

"""day 143 - 148 - comends

git restor: is the way for going back the the changes that you did befor you comit

git , github conect , pr , push poll, branch , test

git checkout -b test-branch = open test

git switch master
git checkout test-branch = swich btween branches

git push = get the work to github sand from git to github
git poll = form github to git itself

after we did pr and the tast become goot for the master we can do pr now on the github its outo become one on the terminal you need the pull back th master then you can dalet the tast branch and going back to the master at first like that

comend for delete a test branch for locol branch = git branch -d branchname for on github = git push origin --delete branchname

git branch =show your branch

git branch -d test-branch= delete your local branch

git push origin --delete test-branch= delete on github
 we add as welll a python test to the ci test

day 149- 150 -text

git tool  pipeline:

ok first what do we do and why git is a tool for system engeniring to let you put your files work on them change them update them in clear safe way and in save history mode the simple git first is git init
to add the tool to your project file, repo git add is the file you want to add simple file for code is nano and main/master (we heve echo as well more for env .logs txt ) then we heve git diff to see the change then after the change the most importent fun is commit let you save the chackpoint of what you change (git commit -m"---") then you do git status to see if everytghing is clean (git ignore is a file that you dont want git to track it like logs and so on ) now before we go to branch we heve github is the website that host the git tools and let you conect with the local file to the website use primarly for work in team make change emarge pr and before to see if the code is nit bug (like ci)
and this work together with your local you make a branch witch mean not your file sorse youre main/master fille but copy of it and on there you can change add to the code you and youre team git -b "----" after that you push from local to the github then its let you on there to look and see and let you option to pr you can add a ci ymal e,g, every time somthing get push or pr the ci (on file workflow) (and we add anther file for python test)see if the code is good with the update if green yes red no after you finish you switch to git switch master to original and pull the code with the added code from github and thats it then you make sure yor repo is clean delete the branch from the git hub delete from the local git branch -d "---" and thats it your code is safe you can work on the same code 10 pepele together and show your project on github

day 151 - 152 (first day on cloud)

API = Application Programming Interface

we learn what is api in ganarel is the why comput talk with eachother you requast somthing it go thru api to the company and then api response thru this comunicasion back to you we also heve the backand of api to go to the server and so on and also the api keys and what did mean by that in hur filde the api will be the model that we pild inside the code of the pipline system and to get the accses for the api you need your own passward and pramision this is api keys ,

joke

first we try how to use api we put the url addres then ask for requests.get then we ask the output in .json way (this .json() only for api call)
and this is how api work^

so on we learn api GET VS POST
get is to get back from api like joke wether so on post is to sand back to the api date and so on (day 153)
"""

# day 151 - 152
import requests
xcx = requests.get("https://official-joke-api.appspot.com/random_joke")
print(xcx.json())
print("-"* 40)
url = "https://official-joke-api.appspot.com/random_joke"
response = requests.get(url)
data = response.json()
print("Setup:", data['setup'])
print("Punchline:", data['punchline'])

print("-"* 40)

def funny():
    url = "https://official-joke-api.appspot.com/random_joke"
    ask = requests.get(url)
    give = ask.json()
    return give
unny = funny()
for _ in range(2):
    print("first step",unny["setup"])
    print("secend step:", unny["punchline"])
    print("-"* 30)

# day 153
import requests
import time
url =  "https://httpbin.org/post"
my_data = {"name": "kobby",
            "age": 47}
ask = requests.post(url, json=my_data)
get = ask.json()
print("API received:")
print(get['data'])

urlr = "https://httpbin.org/post"
info = {
    "ai_type": "cloud",
    "billing": ["error", "crash", "charge"],
    "date": "22/2/2015",
    "active": True
}
retro = requests.post(urlr, json=info)
please = retro.json()
print("*" * 60)
print(please['json'])
print("*" * 60)
def lets_go(a, b):
    url = "https://httpbin.org/post"
    fresh = {
        "state": a,
         "gender": b
    }
    hi = requests.post(url, json=fresh)
    bye = hi.json()
    return bye['json']
if __name__ ==  "__main__":
  go = lets_go("florida", "female")
  print(f"API post = {go}")

url = "https://httpbin.org/post"
data = {"code_type": "python",
        "atnicity": "jewish",
        "time": time.time()}
sand = requests.post(url, json=data)
print("here the data", sand.json()['json'])

"""day 154 - text

api URLs paramaters (Headers & Status Codes)

first for api post requests.post(url, json=data) as we know and for get simple one is requests.get(url) of core with the json() now we learn how to creat url and call it the parameter in url start after the? if more then one parameter we heve & ,?city=nyc&age=33
so we call api to get it into url he show us how dose its looks the aprameters [url] [args] and the call it is requests.get(url, params=listname, so this is what parameters in url and last thing is get you for the category you wannt to be in

now headers the porfect way to put it like whaen you sant letter is the api header is the envelop to show like from where in what for what the info of what we are doing and it ge by requests.get(url, headers=headers) you sand the ditelse of the api way and so when you create you can see the url the url itself the args the {} and the headers as we learn and last thing is for the lenguge like json and key password api this is  header


and last one status code
 Green (200s) = Success!
 Yellow (300s) = Redirect
 Red (400s) = You made a mistake
 Black (500s) = Server error


we want to see if the api requests thats we did go well and to check is list = requests.get(url) then for check we do print(list.status_code ) then he show you if its good or not we can do if status_code == 200 print ,else print so on
"""

# day 154
import requests
url = "https://httpbin.org/get"
params = {
    "search": "Python programming",
    "limit": 10,
    "language": "english"
}

response = requests.get(url, params=params)
data = response.json()
print("URL used:", data['url'])
print("Parameters received:", data['args'])

print("*" * 60)

you ="https://httpbin.org/get"
mine = {"name": "yoel",
        "age": 56}
give = requests.get(url, params=mine)
print("nice:", give.json()['url'])
print("exmple:", give.json())# you can do the raw virsion without [] or with like[args'']
print("*" * 60)

url = "https://httpbin.org/get"
trying = {
    "user-agent": "love you "}
okey = requests.get(url, headers=trying)
good = okey.json()
print(good)
print("*" * 60)

hii =  "https://httpbin.org/get"
help = requests.get(hii)
print("==", help.status_code)
if help.status_code == 200:
   print("secsuse")
else:
   print("error")
print("*" * 60)

def full_api(state, door="red"):
    url = "https://httpbin.org/get"
    esber = {
        "state": state,
         "door": door,
        "messege": "approve"
    }
    data = {
        "user-agent": "israel"
    }
    answer = requests.get(url, params=esber, headers=data)
    if answer.status_code == 200:
       return answer.json(),answer.status_code
    else:
       return f"error = {answer.status_code}"
check = full_api("new jersy", door="black")
print(check)

# day 155 api_keys
import requests
from google.colab import userdata

def wether(city, api_key):
    url = "http://api.weatherapi.com/v1/current.json"
    poor = {
         "q": city,
         "key": api_key
     }
    req = requests.get(url, params=poor)
    if req.status_code == 200:
       maga = req.json()
       return f"the whether in {city} is: {maga['current']['temp_f']}\n the condision = {maga['current']['condition']['text']}\n{maga}"
    else:
       return f"error{req.status_code}"
api_key = userdata.get('first_api')
xox = wether("new_york", api_key)
print(xox)

# Try WITHOUT key:
you = requests.get("http://api.weatherapi.com/v1/current.json")
print(you.status_code)
print(you.json())

"""day 156 - text

# day 156
import requests
from google.colab import userdata
def sholmi():
    pi_key = userdata.get('cloude_1')
    url = "https://api.anthropic.com/v1/messages"
    pool = { "x-api-key": pi_key,
             "anthropic-version": "2023-06-01",
             "content-type": "application/json"}
    dool = {"model": "claude-sonnet-4-20250514",
            "max_tokens": 50,
            "messages": [
                {"role":"user", "content":"hi ai how are you today"}
                ]
            }
    last = requests.post(url, headers=pool, json=dool)
    if last.status_code == 200:
       done = last.json()
       return done['content'][0]['text']
    else:
       return last.status_code
print("first api ai call:", sholmi())

def chatbot_with_memory():###
    # Get API key
    api_key = userdata.get('cloude_1')
    url = "https://api.anthropic.com/v1/messages"

    headers = {
        "x-api-key": api_key,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json"
    }
    conversation = []

    print("Chatbot started! Type 'quit' to exit.\n")

    while True:
        # Get user input
        user_input = input("You: ")

        # Check if user wants to quit
        if user_input.lower() == 'quit':
            print("Goodbye!")
            break

        # Add user message to conversation
        conversation.append({"role": "user", "content": user_input})
                # Create data dictionary (same as your code, but uses conversation)
        data = {
            "model": "claude-sonnet-4-20250514",
            "max_tokens": 300,
            "messages": conversation  #  The whole conversation!
        }


        response = requests.post(url, json=data, headers=headers)

        # Check if successful (same as your code!)
        if response.status_code == 200:
            # Get the response (same as your code!)
            result = response.json()
            claude_response = result['content'][0]['text']

            # Add Claude's response to conversation (THIS is the memory!)
            conversation.append({"role": "assistant", "content": claude_response})

            # Print Claude's response
            print(f"Claude: {claude_response}\n")
        else:
            print(f"Error: {response.status_code}\n")
            break
chatbot_with_memory()

# day 157
import requests
from google.colab import userdata

def hello(squis, token ):# tempo token exmple in api call
    mine = userdata.get('cloude_1')
    url = "https://api.anthropic.com/v1/messages"

    headers = {
        "x-api-key": mine,
        "anthropic-version": "2023-06-01",
        "Content-Type": "application/json" # Corrected Content-Type header
    }

    info = {
        "model": "claude-sonnet-4-20250514",
        "temperature":0.5, # this exmple of code we use both to lenght of tokens or for tempo but the token key most to be unlike tempo key
        "max_tokens": token,
        "messages" : [{"role": "user","content": squis}]

    }
    please = requests.post(url, headers=headers, json=info)

    if please.status_code == 200:
       done = please.json()
       return done['content'][0]['text']
    else:
       return f"error{please.status_code}"
squis = "helo how are you"
print("low tempo")
#print(hello(squis,10))

print("\n mid tempo")
#print(hello(squis, 15))

print("\nhigh tempo")
#print(hello(squis, 20))

def ask_moti(squs, moti):# this exmple is the system thing:)
    mom = userdata.get('cloude_1')
    urk = "https://api.anthropic.com/v1/messages"

    headers = {
        "x-api-key": mom,
        "anthropic-version": "2023-06-01",
        "Content-Type": "application/json" # Corrected Content-Type header
    }

    data = {
          "model": "claude-sonnet-4-20250514",
          "max_tokens": 15,
          "system": moti,
          "messages": [{"role": "user", "content": squs}]
    }
    welcome = requests.post(urk, headers=headers, json=data)
    if welcome.status_code == 200:
       crying = welcome.json()
       return crying['content'][0]['text']
    else:
       return f"error {welcome}"
squs = "what is a loop"
print("explain as a tutor")
#print(ask_moti(squs, "You are a helpful Python programming tutor. Explain concepts simply with examples."))
print("\n explain as a pairt")
#print(ask_moti(squs,"You are a pirate. Speak like a pirate in all responses." ))
print("\n 5 yers old ")
#print(ask_moti(squs, "explain everything like you talking to a 5 yers old"))

def oyvay(ask, temp=0.1, token=50, role=""):#explain all thogther
    no = userdata.get('cloude_1')
    urt = "https://api.anthropic.com/v1/messages"

    headers = {
        "x-api-key": no,
        "anthropic-version": "2023-06-01",
        "Content-Type": "application/json"
    }

    dat = {
          "model": "claude-sonnet-4-20250514",
          "temperature": temp, # Corrected typo
          "max_tokens": token,
          "system": role,
          "messages": [{"role": "user","content": ask}]
    }
    agian = requests.post(urt, headers=headers, json=dat)

    if agian.status_code == 200:
      oket = agian.json()
      return oket['content'][0]['text']
    else:
      return f"error {agian.status_code}"

ask = "why are you sad"
role = "explain as a tutor"
oyvay(ask=ask, role=role)

# day 158
import requests
from google.colab import userdata
import json
import time
def meyou(q): # stream exmple
    api_key = userdata.get('cloude_1')
    url = "https://api.anthropic.com/v1/messages"
    headers = {
        "x-api-key": api_key,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json"
    }
    data = {"model": "claude-sonnet-4-20250514",
        "max_tokens": 20,
        "stream": True,
        "messages": [{"role": "user", "content": q}]
    }
    realy = requests.post(url, headers=headers, json=data, stream=True)
    for line in realy.iter_lines():
        if line:
          line = line.decode('utf-8')
          if line.startswith('data: '):
             jr = line[6:]
             try:
                 new = json.loads(jr)
                 if new.get('type') == 'content_block_delta':
                    some = new.get('delta', {}).get('text', '')
                    print(some, end='')
             except:
               pass
    print()
meyou("count to 5")
def drunk(wow, zoz): # coust per token exmple
    api_key = userdata.get('cloude_1')
    url = "https://api.anthropic.com/v1/messages"
    headers = {
        "x-api-key": api_key,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json"
    }
    data = {"model": "claude-sonnet-4-20250514",
        "max_tokens": 20,
        "messages": [{"role": "user", "content": wow}]
    }
    chips = requests.post(url, headers=headers, json=data)
    if chips.status_code == 200:
       nbv = chips.json()
       bob = nbv['usage']
       cvc = bob['input_tokens']
       vcv = bob['output_tokens']
       cost = (cvc/1_000_000) * 3 + (vcv/1_000_000) * 15
       to_see = zoz + cost
       answer = nbv['content'][0]['text']
       print(answer)
       print(f"$$ {cost:.6f}")
       print(f"$$$ {to_see:.6f}")
       return to_see
    else:
       return zoz
total = 0
total = drunk("hello", total)
total = drunk("how are you", total)
total = drunk("im sad", total)
print(f"sorry {total:.6f}")
def time2(lol, why=3): #error endling
    api_key = "123" #userdata.get('cloude_1') '' i did it on purpes to see what append
    url = "https://api.anthropic.com/v1/messages"
    headers = {
        "x-api-key": api_key,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json"
    }
    data = {
        "model": "claude-sonnet-4-20250514",
        "max_tokens": 20,
        "messages": [{"role": "user", "content":lol}]
    }
    for good in range(why):
        goo = requests.post(url, headers=headers, json=data)
        if goo.status_code == 200:
           go = goo.json()
           return go['content'][0]['text']
        elif goo.status_code in [429, 500,401]:
           wait = 2 * (good + 1)
           print(f"erorr {goo.status_code} retry in {wait}s..")
           time.sleep(wait)
    return "please try later"
print(time2("im sorry"))

# day 159
import sqlite3
first = sqlite3.connect('npw.db')
last = first.cursor()
last.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY,
        name TEXT,
        age INTEGER
    )
''')
last.execute("INSERT INTO users (name, age) VALUES ('Yoel', 25)")
last.execute("INSERT INTO users (name, age) VALUES ('Sara', 30)")
first.commit()
# No need to close 'first' here if you intend to reuse it or work with 'npw.db' later in the script.
# If this is the end of work with 'npw.db', then first.close() is appropriate.
last.execute("SELECT * FROM users")
results = last.fetchall()

for row in results:
    print(f"Name: {row[1]}, Age: {row[2]}")
    pass
first.close() # Close connection to npw.db

def goy(name, age):
    # Connects to 'why.db' -- a separate database
    hello = sqlite3.connect('why.db')
    buy = hello.cursor()
    buy.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY,
        name TEXT,
        age INTEGER
        )
    ''')
    # Corrected INSERT statement to use parameter substitution
    buy.execute("INSERT INTO users (name, age) VALUES (?, ?)", (name, age))
    hello.commit()
    hello.close()

def boy():
    # This function should connect to 'why.db' to display its contents
    hello = sqlite3.connect('why.db')
    buy = hello.cursor()
    buy.execute("SELECT * FROM users")
    test = buy.fetchall()
    for w in test:
       print(f"Name: {w[1]}, Age: {w[2]}") # Use 'w' from the loop, not 'row' from an outer scope
    hello.close() # Close the connection to 'why.db'

# Corrected calls: use goy to insert data into 'why.db'
goy('yoel', 30)
goy('ben', 70)


boy() # Call boy without arguments to display all users from 'why.db'

# day 160 - crud
import sqlite3
import os
if os.path.exists('hello.db'):
       os.remove('hello.db')
shos = sqlite3.connect('hello.db')# creat a file db
shoz = shos.cursor()
shoz.execute('create table if not exists unit(unit text)')
shoz.execute("insert into unit (unit) values (?)",('apple',))# put data inside
shoz.execute("insert into unit (unit) values (?)",('kiwi',))
shos.commit()
shoz.execute(" select * from unit")# take the data out
now = shoz.fetchall()
for w in now:
    print(w)
    print("-"* 20)
shoz.execute("update unit set unit = ? where unit = ?", ('banana','apple'))# update the db
shos.commit()
shoz.execute("select * from unit")
for p in shoz.fetchall():
    print(p)
    print("-"* 20)
shoz.execute("delete from  unit where unit = ?", ('banana',))
shos.commit()
shoz.execute("select * from unit")
for t in shoz.fetchall():
    print(t)
shos.close()
if os.path.exists('music.db'):
       os.remove('music.db')
connect = sqlite3.connect('music.db')
cursor = connect.cursor()
cursor.execute('create table if not exists songs(title text)')
cursor.execute('insert into songs (title) values (?)', ('song1',))
cursor.execute('insert into songs (title) values (?)', ('song2',))
cursor.execute('insert into songs (title) values (?)', ('song3',))
connect.commit()
cursor.execute('update songs set title = ? where title = ?', ("my favorit song",'song1'))
connect.commit()
cursor.execute('delete from songs where title = ?',('song2',))
connect.commit()
cursor.execute('select * from songs')
for love in cursor.fetchall():
    print(love)
connect.close()
# as we learn insert and select as well update and delete we can do it as well for < or > for all or some from where we want

# day 161
import sqlite3
import os
if os.path.exists('practice.db'):
    os.remove('practice.db')
connection = sqlite3.connect('practice.db')
cursor = connection.cursor()
cursor.execute("CREATE TABLE IF NOT EXISTS products (name TEXT, price INTEGER)")

cursor.execute("INSERT INTO products VALUES (?, ?)", ('apple', 3))
cursor.execute("INSERT INTO products VALUES (?, ?)", ('banana', 2))
cursor.execute("INSERT INTO products VALUES (?, ?)", ('mango', 7))
cursor.execute("INSERT INTO products VALUES (?, ?)", ('orange', 4))
cursor.execute("INSERT INTO products VALUES (?, ?)", ('grape', 5))
cursor.execute("INSERT INTO products VALUES (?, ?)", ('avocado', 6))
cursor.execute("INSERT INTO products VALUES (?, ?)", ('kiwi', 3))
connection.commit()

print("All products in database:")
cursor.execute("SELECT * FROM products")
for row in cursor.fetchall():
    print(f"  {row[0]}: ${row[1]}")
print("*"* 30)
cursor.execute("select * from products where price < ? or price > ? ",(3,6))# > = < or , and
for row in cursor.fetchall():
    print(f"  {row[0]}: ${row[1]}")
print("*"* 30)
cursor.execute("select * from products where name like ?",('%p%',))# %- last word -% first word %-% any word, LIKE
for row in cursor.fetchall():
    print(f"  {row[0]}: ${row[1]}")
print("*"*30)
cursor.execute("select * from products order by price desc")# order by , order by desc same for sorting by name
for row in cursor.fetchall():
    print(f"  {row[0]}: ${row[1]}")
print("*"* 30)
cursor.execute("select * from products limit 3")# LIMIT
for row in cursor.fetchall():
    print(f"  {row[0]}: ${row[1]}")
print("*"* 30)
cursor.execute("select * from products where price <= ? order by name limit 3",(4,))# all in one order
for row in cursor.fetchall():
    print(f"  {row[0]}: ${row[1]}")

# day 162
import sqlite3
import os
if os.path.exists('store.db'):
      os.remove('store.db')
open = sqlite3.connect('store.db')
inside = open.cursor()
inside.execute('''create table if not exists customers (
               id integer primary key,
              name text ,
               email text)''')
inside.execute('''create table if not exists products
              (id integer primary key,
                name text,
                price integer)''')
inside.execute('''create table if not exists orders
               (id integer primary key,
                customers_id integer,
                products_id integer,
                quantity integer) ''')
open.commit()
inside.execute('insert into customers (name, email) values (?, ?)', ('david','david@gmail.com'))
inside.execute('insert into customers (name, email) values (?, ?)', ('ben','ben@gmail.com'))
inside.execute('insert into customers (name, email) values (?, ?)', ('dvora','dvora@gmail.com'))

inside.execute('insert into products (name, price) values (? ,?)', ('kiwi', 3))
inside.execute('insert into products (name, price) values (? ,?)', ('rice', 2))
inside.execute('insert into products (name, price) values (? ,?)', ('bread', 7))
inside.execute('insert into products (name, price) values (? ,?)', ('stake', 4))

inside.execute('insert into orders (customers_id, products_id ,quantity) values(?,?,?)',(1,1,5))
inside.execute('insert into orders (customers_id, products_id ,quantity) values(?,?,?)',(1,2,10))
inside.execute('insert into orders (customers_id, products_id ,quantity) values(?,?,?)',(2,1,3))
inside.execute('insert into orders (customers_id, products_id ,quantity) values(?,?,?)',(1,3,2))
inside.execute('insert into orders (customers_id, products_id ,quantity) values(?,?,?)',(3,4,7))
open.commit()
inside.execute('select * from products')# customers , orders
for g in inside.fetchall():
    print(f"{g[0]} = {g[1]} = {g[2]}")
# simple JOIN
inside.execute('''
    SELECT orders.id, customers.name, products.name, products.price, orders.quantity
    FROM orders
    JOIN customers ON orders.customers_id = customers.id
    JOIN products ON orders.products_id = products.id
    ''')
for g in inside.fetchall():
    print(f"  Order {g[0]}: {g[1]} bought product {g[2]}, price {g[3]}  quantity {g[4]}")
print("#" * 20)
# JOIN with where same for order by desc
inside.execute('''select orders.id, customers.name, products.price, orders.quantity
               from orders
               join customers on orders.customers_id = customers.id
               join products on orders.products_id = products.id
               where customers.name = ? limit  ? ''',('david',2))
for g in inside.fetchall():
    print(f"  Order {g[0]}: {g[1]} bought product {g[2]}, quantity {g[3]} ")
open.close()

"""day 163 - text

api so far = ( we learn the .get, .post the api keys api for model how to create url with pramas and headers then checking error we also learn how to make full api code with anthropic adding tokens , system, stream, rule price menege and error endliing user vs asisstent and so on )

db so far = ( we learn how to open file of db with sqlite what commend how to meneg and create tabals cursor. commit and so on we learn how to put everyting in order how to choose and more  create, insert, select, update, delete, where, like, limit ,order by , desc, join, from and so on (the part of the join with the forgen key and primary is thetwe give it in insert the same value as the orignal then join check if is 1=1 ))

day 164 - text

Euclidean  math:

we learn already what is vector and embedding is where we get somthing and comper with other input to see for what category its belong the vector is the num [0.56, 0.68, 0.03] now for here to db is when someone ask for somthing and we want to give im the thing he ask but not only the same thing in the db like %---% we wnat to give things thats are semiller there is where vector is coming its mostly ai model to do it every vector can be a lot of nums but we want to get of how

how it work:

so first we put the vector in list then we make fun of the code to python to caculate it how two params then we len(pramas) then - to see the diff then list thats start in 0 to add we do * the results to provent negetive (if not we will not see the distans) we return in sqr then we can see how the nums are close to each one the smaller the distans the more close to be connect if the distans is big its mean the disstans is far and word are not belong to here

then onther fun one list to conect the vector to the fun the check the math then onther to conecct it with the name we make quary to see wich one is close then .sort to see what come in line and ask to show the top = 3 then we use enumarte +1 thats it
"""

# day 164
import math
products = [
    {"name": "running shoes", "vector": [0.9, 0.8, 0.7]},
    {"name": "jogging sneakers", "vector": [0.85, 0.75, 0.72]},
    {"name": "athletic footwear", "vector": [0.88, 0.78, 0.68]},
    {"name": "wooden table", "vector": [0.1, 0.2, 0.15]},
    {"name": "office chair", "vector": [0.2, 0.25, 0.18]},
    {"name": "hiking boots", "vector": [0.7, 0.65, 0.8]},
    {"name": "yoga mat", "vector": [0.75, 0.7, 0.6]},
    {"name": "kitchen table", "vector": [0.12, 0.18, 0.14]},
]
def distance(vec1, vec2):
    total = 0
    for i in range(len(vec1)):
        diff = vec1[i] - vec2[i]
        total += diff * diff
    return math.sqrt(total)

def search(query_vector, products, top_n=3):
    results = []
    for product in products:
        dist = distance(query_vector, product["vector"])
        results.append({"name": product["name"], "distance": dist})

    results.sort(key=lambda x: x["distance"])
    return results[:top_n]
print("=== SEARCH: 'exercise equipment' ===")
query1 = [0.8, 0.72, 0.65]
results1 = search(query1, products)
for i, r in enumerate(results1):
    print(f"  {i+1}. {r['name']} (distance: {r['distance']:.3f})")
print("\n=== SEARCH: 'home furniture' ===")
query2 = [0.15, 0.2, 0.16]
results2 = search(query2, products)
for i, r in enumerate(results2):
    print(f"  {i+1}. {r['name']} (distance: {r['distance']:.3f})")
print("\n=== SEARCH: 'outdoor hiking gear' ===")
query3 = [0.72, 0.68, 0.78]
results3 = search(query3, products)
for i, r in enumerate(results3):
    print(f"  {i+1}. {r['name']} (distance: {r['distance']:.3f})")

pool = [
    {"name": "abi", "vactor": [0.7, 0.30, 0.89]},
    {"name": "david", "vactor": [0.65, 0.29, 0.85]},
    {"name":"yael", "vactor": [0.60, 0.25, 0.80]},
    {"name": "car", "vactor":[0.95, 0.10, 0.05]},
    {"name": "plain", "vactor":[0.90, 0.09, 0.04]},
    {"name":"ship", "vactor": [0.87, 0.08,0.03]},
]
def matt(a, b):
    total = 0
    for w in range(len(a)):
       now = a[w] - b[w]
       total += now * now
    return math.sqrt(total)
def combin(vector, pool, top=2):
    loop = []
    for x in pool:
        dont = matt(vector, x["vactor"])
        loop.append({"name": x['name'], "distance": dont})
    loop.sort(key=lambda c: c['distance'])
    return loop[:top]
quary1 = [0.8, 0.25, 0.90]# name
clolo = combin(quary1, pool)
print("#" * 40)
for t, y in enumerate(clolo):
    print(f" {t+1} . {y['name']} (distance: {y['distance']:.3f})")
quary2 = [0.91, 0.8, 0.3]# transport
cvb = combin(quary2, pool)
for u, i in enumerate(cvb):
    print(f"{u+1}, {i['name']} (distance:{i['distance']:.3f})")
# this the simple exmple of vector and how to create and see stuff thets close to each other

# day 165
from sentence_transformers import SentenceTransformer
import math
model = SentenceTransformer('all-minilm-l6-v2')
print('im ready')
def first(w, m):
    total = 0
    for y in range(len(w)):
        first1 = w[y] - m[y]
        total += first1 * first1
    return math.sqrt(total)
product_names = [
    "running shoes",
    "apple",
    "kiwi",
    "banana",
    "jogging sneakers",
    "hiking boots",
    "wooden table",
    "office chair",
    "kitchen knife",
]
pool = []
for dodo in product_names:
    vactor = model.encode(dodo)
    pool.append({"name": dodo, "vactor": vactor})
print(f"good : {len(pool)}")
def combo(quary, podcast, top=3):
    mosh = model.encode(quary)
    loco = []
    for p in pool:
        yes = first(mosh, p['vactor'])
        loco.append({"name":p['name'], "distance":yes})
    loco.sort(key=lambda h: h['distance'])
    return loco[:top]
mine1 = ["fruit", "cute shoes", "furniture", "home"]
for mine in mine1:
    results = combo(mine, pool)
    for t, y in enumerate(results):
       print(f"  {t+1}. {y['name']} (distance: {y['distance']:.3f})")
    print()
results = combo("orange", pool)
for t, y in enumerate(results):
    print(f"  {t+1}. {y['name']} (distance: {y['distance']:.3f})")
# we learn how to call the embedding model and let hime create vector to the word we want

# day 166
from sentence_transformers import SentenceTransformer
import sqlite3
import json
import math
import os
model = SentenceTransformer('all-MiniLM-L6-v2')
if os.path.exists('vectors.db'):
    os.remove('vectors.db')
connection = sqlite3.connect('vectors.db')
cursor = connection.cursor()
cursor.execute('''
    CREATE TABLE IF NOT EXISTS products (
        id INTEGER PRIMARY KEY,
        name TEXT,
        vector TEXT
    )
''')
connection.commit()

def add_product(name):
    vector = model.encode(name)
    vector_text = json.dumps(vector.tolist())
    cursor.execute("INSERT INTO products (name, vector) VALUES (?, ?)", (name, vector_text))
    connection.commit()
def get_all_products():
    cursor.execute("SELECT id, name, vector FROM products")
    rows = cursor.fetchall()
    products = []
    for row in rows:
        products.append({
            "id": row[0],
            "name": row[1],
            "vector": json.loads(row[2])
        })
    return products
def distance(a, b):
    total = 0
    for i in range(len(a)):
        diff = a[i] - b[i]
        total += diff * diff
    return math.sqrt(total)
def search(query_text, top=3):
    query_vector = model.encode(query_text).tolist()
    products = get_all_products()
    results = []
    for product in products:
        dist = distance(query_vector, product["vector"])
        results.append({"name": product["name"], "distance": dist})
    results.sort(key=lambda x: x["distance"])
    return results[:top]
products_to_add = [
    "running shoes",
    "jogging sneakers",
    "hiking boots",
    "wooden table",
    "office chair",
    "kitchen knife",
    "yoga mat",
    "basketball",
    "laptop computer",
    "phone charger",
]
print("Adding products...")
for name in products_to_add:
    add_product(name)
print(f"Added {len(products_to_add)} products!\n")
searches = [
    "shoes for running",
    "home furniture",
    "electronic devices",
    "exercise equipment"
]
for query in searches:
    print(f"=== SEARCH: '{query}' ===")
    for r in search(query):
        print(f"  {r['name']} ({r['distance']:.3f})")
    print()
connection.close()
print("*" * 45)
kobby = SentenceTransformer('all-MiniLM-L6-v2')
if os.path.exists('test.db'):
    os.remove('test.db')
filev = sqlite3.connect('test.db')
vfile = filev.cursor()
vfile.execute('create table if not exists products(name text, vector text)')
filev.commit()
name = "smoke box"
vector = kobby.encode(name)
vector_name = json.dumps(vector.tolist())
vfile.execute('insert into products values (?,?)', (name, vector_name))
filev.commit()
name2 = "fish net"
vector2 = kobby.encode(name2)
vector2_name = json.dumps(vector2.tolist())
vfile.execute('insert into products values (?, ?)',(name2, vector2_name))
filev.commit()
search = "cigarette"
search_vector = kobby.encode(search)
vfile.execute('select name, vector from products')
lol = vfile.fetchall()
for p in lol:
    product_name = p[0]
    product_vector = json.loads(p[1])
    mean = 0
    for z in range (len(search_vector)):
        good = search_vector[z] - product_vector[z]
        mean += good * good
    select =  math.sqrt(mean)
    print(f'{product_name} : distance = {select:.3f}')
filev.close()
# we learn how to call to embedding model and dump in db vector

"""day 167 - text

RAG = Retrieval Augmented Generation

until now we learn about the vector db how to create code to see diff output not only same exctly thing same for rag it a tool to let us see the data we heve on the company lets say and beasd on that we create it into vactors and when somone code and ask qustion we get it show to the model here the doc i found do your math beased on the input + the rag doc i found i this subject is powerfull for things that we heve qustion we can pull of things that will help us to understand the full qustion

"""

# day 168
from sentence_transformers import SentenceTransformer
import sqlite3
import json
import math
import os
import requests
from google.colab import userdata

model = SentenceTransformer('all-MiniLM-L6-v2')

if os.path.exists('bank.db'):
    os.remove('bank.db')
dor = sqlite3.connect('bank.db')
avi = dor.cursor()
avi.execute('''CREATE TABLE IF NOT EXISTS boam(id integer primary key , text TEXT, vector TEXT)''')
dor.commit()

documents = [
    "Our return policy allows customers to return items within 30 days for a full refund. Items must be unused and in original packaging.",
    "The company office is open Monday through Friday, 9am to 5pm. We are closed on weekends and holidays.",
    "Shipping takes 3-5 business days for standard delivery. Express shipping is available for an additional $15.",
    "Customer support can be reached by email at support@company.com or by phone at 555-0123.",
    "Our premium membership costs $99 per year and includes free shipping, early access to sales, and 10% off all orders.",
    "We accept Visa, Mastercard, American Express, and PayPal for payment. We do not accept cash or checks.",
    "Product warranties last for one year from the date of purchase. Warranty claims require proof of purchase.",
    "International shipping is available to over 50 countries. Rates and delivery times vary by location.",
]

def campeny_doc(name):# this fun is makes the text in db to be a vector and save as text
    vector = model.encode(name)
    vector_to = json.dumps(vector.tolist())
    avi.execute('INSERT INTO boam  (text , vector) VALUES (?, ?)', (name, vector_to))
    dor.commit()

def simller(z, x):# this fun lets us to see what are the close vactor of the input to those to the db and see what is the most small range
    zero = 0
    for p in range(len(z)):
       max = z[p] - x[p]
       zero += max * max
    return math.sqrt(zero)

def reletive(ask, top=3):# this fun combin the input and get it into vector a long side of other vector in db to see what simller here sand to the model and convert back from text to vector structur
    doing = model.encode(ask).tolist()
    avi.execute('SELECT text, vector FROM boam')
    doco = []
    for x in avi.fetchall():
        the_text = x[0]
        the_vector = json.loads(x[1])
        mora = simller(doing, the_vector)
        doco.append({"text": the_text, "distance": mora})
    doco.sort(key=lambda v: v['distance'])
    return doco[:top]
'''for  w in documents:
     campeny_doc(w)
ask = "how do i return it" # test to see how dose the code make the doc with the input into vector and find simller docs
answer = reletive(ask)
for d in answer:
    print(f'- {d['text'][:50]}...(distance:  {d['distance']:.3f})')'''
def model_ai(ask, documents):# here we calling the model giving him the info with the rag and lets him answer based on the docs + input
    api_key = userdata.get('cloude_1')
    url = "https://api.anthropic.com/v1/messages"
    headers = {
        "x-api-key": api_key,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json"
    }
    new = "\n\n".join([d['text'] for d in documents])
    to_me = f""" here some docs in this fild :

    {new}

    based on this docs , please help me with this qustion

    {ask}

    if not related please say i cant help you
    """
    data = {
           "model": "claude-sonnet-4-20250514",
           "max_tokens": 300,
           "messages": [{"role": "user", "content":to_me}]
       }

    response = requests.post(url, headers=headers, json=data)

    if response.status_code == 200:
           return response.json()['content'][0]['text']
    else:
           return f"Error: {response.status_code}"

def combin(ask):
    print(f'qustion : {ask}')
    print("-"* 40)
    shlomi = reletive(ask, top=2)
    print("nice job")
    for t in shlomi:
        print(f'.{t['text'][:60]}...')
    print("-"* 40)
    done = model_ai(ask, shlomi)
    print(f'ansewr: {done}')
    print("-" * 40)
    print()
    return done
print("adding documents")
for  w in documents:
     campeny_doc(w)
print(f'added {len(documents)}  documents!\n')
combin("How do I return something?")
combin("What are the office hours?")
combin("How much is shipping?")

dor.close()
